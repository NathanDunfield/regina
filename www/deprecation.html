<html>
<head>
    <link rel="stylesheet" type="text/css" href="regina.css">
    <title>Regina - Deprecation Guide</title>
</head>
<body bgcolor="#FFFFFF" text="#000000"
    link="#0000EE" vlink="#551A8B" alink="#FF0000" class="deprecation">

<h1><a name="contents">Regina - Deprecation Guide</a></h1>

<div class="announce"><p>
This page relates only to <b>C++ and Python programmers</b>.
</p></div>

<p>
Over the years, several outdated routines and classes within Regina's
calculation engine have become <i>deprecated</i>, and have been marked
for deletion at some future date.
</p>
<p>
That future date is now approaching.  <b>With the release of
Regina&nbsp;5.0, all of the deprecated code will be removed.</b>
If you use any of this deprecated code, your Python
scripts or C++ programs will no longer work.
</p>
<p><h4><span class="question">When will this change happen?</span></h4></p>
<p>
There is still a lot to do before Regina&nbsp;5.0 &mdash; realistically,
this release <b>will not happen until 2010</b> at the earliest.
There will be point releases before then (such as 4.6.1 which is
expected in late 2009), but no code will be removed until Regina&nbsp;5.0.
</p>
<p><h4><span class="question">How do I fix my code?</span></h4></p>
<p>
The following table lists the routines and classes that will be
removed, as well as the replacements that you can use instead.
Any changes in the <i>behaviour</i> of these routines or classes
are noted in the comments column.
</p>
<p>
<table cellspacing=0 border=0 class="data"><tbody>
<tr>
    <th class="first">Deprecated code</th>
    <th>Replacement</th>
    <th>Comments</th>
</tr>
<tr><td class="altfirst" colspan=4><i>Namespaces</i></td></tr>
<tr>
    <td class="first"><tt>stdhash</tt></td>
    <td>&mdash;</td>
    <td>To improve portability, all references to the non-standard
        STL classes <tt>hash_set</tt> and <tt>hash_map</tt> will be
        removed from Regina.</td>
</tr>
<tr><td class="altfirst" colspan=4><i>Classes</i></td></tr>
<tr>
    <td class="first"><tt>HashPointer</tt>,
        <tt>HashString</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>stdhash</tt> namespace.</td>
</tr>
<tr>
    <td class="first"><tt>NDoubleDescriptor</tt></td>
    <td><tt>NDoubleDescription</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>NFile</tt></td>
    <td>&mdash;</td>
    <td>The <tt>NFile</tt> class exists purely to support the old binary file
    format that was phased out back in 2002.  Regina&nbsp;5.0 will drop
    support for this old binary file format entirely.</td>
</tr>
<tr>
    <td class="first"><tt>NFilePropertyReader</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NIndexedArray</tt></td>
    <td>&mdash;</td>
    <td><tt>NMarkedVector</tt> does a similar job (and is smaller and faster),
        though it requires changes to the data types in your array.</td>
</tr>
<tr>
    <td class="first"><tt>NIsomorphismDirect</tt></td>
    <td><tt>NIsomorphism</tt></td>
    <td><tt>NIsomorphism</tt> now contains all the functionality of
    the old <tt>NIsomorphismDirect</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NIsomorphismIndexed</tt></td>
    <td>&mdash;</td>
    <td>Instead, use <tt>NIsomorphism</tt> in conjunction with the
        <tt>NPerm::S4</tt> array.</td>
</tr>
<tr>
    <td class="first"><tt>NPermItS4</tt></td>
    <td>&mdash;</td>
    <td>Instead, just loop through the elements
        of <tt>NPerm::S4</tt> directly.</td>
</tr>
<tr>
    <td class="first"><tt>NRandomAccessResource</tt>,
        <tt>NLocalFileResource</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr><td class="altfirst" colspan=4><i>Member Routines</i></td></tr>
<tr>
    <td class="first"><tt>...::readFromFile(NFile&amp;, ...)</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>...::writeToFile(NFile&amp;)</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NLayeredLoop::getIndex()</tt></td>
    <td><tt>NLayeredLoop::getLength()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>NPacket::readPacket()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NPacket::writePacket()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NPerm::setPerm()</tt></td>
    <td>&mdash;</td>
    <td>Instead, just use the assignment operator, as in
        <tt>p = NPerm(1,2)</tt>.</td>
</tr>
<tr>
    <td class="first"><tt>NSurfaceFilter::readFilter()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NSurfaceFilter::writeFilter()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NSurfaceFilter::writeProperties()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getAdjacentFace()</tt></td>
    <td><tt>NTriangulation::adjacentFace()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getAdjacentTetrahedron()</tt></td>
    <td><tt>NTriangulation::adjacentTetrahedron()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getAdjacentTetrahedronGluing()</tt></td>
    <td><tt>NTriangulation::adjacentGluing()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getBoundaryComponentIndex()</tt></td>
    <td><tt>NTriangulation::boundaryComponentIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given boundary component must belong to the triangulation.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getComponentIndex()</tt></td>
    <td><tt>NTriangulation::componentIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given component must belong to the triangulation.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getEdgeIndex()</tt></td>
    <td><tt>NTriangulation::edgeIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given edge must belong to the triangulation.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getEulerCharacteristic()</tt></td>
    <td><tt>NTriangulation::getEulerCharTri()</tt> or
        <tt>NTriangulation::getEulerCharManifold()</tt></td>
    <td>Note that the two replacement routines give different results
        for ideal triangulations.  The old <tt>getEulerCharacteristic()</tt>
        was equivalent to the new <tt>getEulerCharTri()</tt>.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getFaceIndex()</tt></td>
    <td><tt>NTriangulation::faceIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given face must belong to the triangulation.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getTetrahedronIndex()</tt></td>
    <td><tt>NTriangulation::tetrahedronIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given tetrahedron must belong to the triangulation.</td>
</tr>
<tr>
    <td class="first"><tt>NTriangulation::getVertexIndex()</tt></td>
    <td><tt>NTriangulation::vertexIndex()</tt></td>
    <td>The new routine is faster, but has an extra precondition that
        the given vertex must belong to the triangulation.</td>
</tr>
<tr><td class="altfirst" colspan=4><i>Global Routines</i></td></tr>
<tr>
    <td class="first"><tt>edgeDescription()</tt></td>
    <td><tt>NPerm::trunc2()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>edgeOrdering()</tt></td>
    <td><tt>NEdge::ordering[]</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>faceDescription()</tt></td>
    <td><tt>NPerm::trunc3()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>faceOrdering()</tt></td>
    <td><tt>NFace::ordering[]</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>factorise()</tt></td>
    <td><tt>NPrimes::primeDecomp()</tt>,
        <tt>NPrimes::primePowerDecomp()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>primesUpTo()</tt></td>
    <td><tt>NPrimes::prime()</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>readFromFile()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr>
    <td class="first"><tt>writeToFile()</tt></td>
    <td>&mdash;</td>
    <td>See the comments above for the <tt>NFile</tt> class.</td>
</tr>
<tr><td class="altfirst" colspan=4><i>Global Arrays</i></td></tr>
<tr>
    <td class="first"><tt>edgeNumber[]</tt>,
        <tt>edgeStart[]</tt>, <tt>edgeEnd[]</tt></td>
    <td><tt>NEdge::edgeNumber[]</tt>, <tt>NEdge::edgeVertex[]</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>allPermsS2[]</tt>,
        <tt>allPermsS2Inv[]</tt></td>
    <td><tt>NPerm::S2[]</tt>, <tt>NPerm::invS2[]</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>allPermsS3[]</tt>,
        <tt>allPermsS3Inv[]</tt>, <tt>orderedPermsS3[]</tt></td>
    <td><tt>NPerm::S3[]</tt>, <tt>NPerm::invS3[]</tt>,
        <tt>NPerm::orderedS3</tt></td>
    <td>&nbsp;</td>
</tr>
<tr>
    <td class="first"><tt>allPermsS4[]</tt>,
        <tt>allPermsS4Inv[]</tt>, <tt>orderedPermsS4[]</tt></td>
    <td><tt>NPerm::S4[]</tt>, <tt>NPerm::invS4[]</tt>,
        <tt>NPerm::orderedS4</tt></td>
    <td>&nbsp;</td>
</tr>
</tbody></table>

<p class="return">
<a href="index.html"><img src="return.jpg" alt="Back to main page ..."
    border="0" width="32" height="32" align="middle"></a>
<a href="index.html">Back to main page ...</a></p>

</body>
</html>

