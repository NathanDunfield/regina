dnl
dnl    Regina - A Normal Surface Theory Calculator
dnl    Configure Script Macros
dnl
dnl    Copyright (c) 2002-2009, Ben Burton
dnl    For further details contact Ben Burton (bab@debian.org).
dnl
dnl    This file is free software; you can redistribute it and/or
dnl    modify it under the terms of the GNU General Public License as
dnl    published by the Free Software Foundation; either version 2 of the
dnl    License, or (at your option) any later version.
dnl
dnl    This file is distributed in the hope that it will be useful, but
dnl    WITHOUT ANY WARRANTY; without even the implied warranty of
dnl    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl    General Public License for more details.
dnl
dnl    You should have received a copy of the GNU General Public
dnl    License along with this program; if not, write to the Free
dnl    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
dnl    MA 02110-1301, USA.
dnl
dnl    Note that this copyright notice applies only to macros beginning
dnl    with REGINA_.  Other macros found in acinclude.m4 have been taken
dnl    from external sources; these macros are stored in separate files
dnl    in the admin/ subdirectory and copyright notices can be found in
dnl    these separate files (and in the comments provided with the macros
dnl    themselves).
dnl

dnl    -----------------------------------------------------------------
dnl
dnl                        Macros written for Regina
dnl
dnl    -----------------------------------------------------------------

dnl
dnl    REGINA_CHECK_BOOST_MAKE_CONSTRUCTOR
dnl
dnl    Checks whether the boost.python make_constructor hack is required.
dnl
dnl    Some earlier versions of boost.python do not include the
dnl    make_constructor definitions as expected from python.hpp, and so the
dnl    additional file boost/python/make_constructor.hpp must be explicitly
dnl    included (this is the "hack" that is referred to).
dnl
dnl    AC_DEFINE()s the following variables:
dnl
dnl        BOOST_MAKE_CONSTRUCTOR_HACK: Defined as 1 if the hack is required
dnl                                     (i.e., make_costructor.hpp must be
dnl                                     explicitly included), or remains
dnl                                     undefined otherwise.
dnl
dnl    Example: REGINA_CHECK_BOOST_MAKE_CONSTRUCTOR
dnl
AC_DEFUN([REGINA_CHECK_BOOST_MAKE_CONSTRUCTOR], [
  AC_MSG_CHECKING([whether the boost make_constructor hack is required])

  AC_LANG_PUSH(C++)
  __regina_mkconst_save_cxxflags="$CXXFLAGS"

  CXXFLAGS="$__regina_py_save_cxxflags $BOOST_PYTHON_INCLUDES"

  AC_TRY_COMPILE([
    #include <boost/python.hpp>
    class C { };
    C* create_C() { return new C; }
  ], [
    boost::python::make_constructor(create_C);
  ], [
    AC_MSG_RESULT([no])
  ], [
    AC_MSG_RESULT([yes])
    AC_DEFINE(BOOST_MAKE_CONSTRUCTOR_HACK, 1,
      [Define to 1 if the boost make_constructor hack is required.])
  ])

  CXXFLAGS="$__regina_mkconst_save_cxxflags"
  AC_LANG_POP(C++)
])

dnl
dnl    REGINA_CHECK_COMPILER_FLAG(FLAG, [ACTION-IF-OK], [ACTION-IF-NOT-OK])
dnl
dnl    Modified from KDE_CHECK_COMPILER_FLAG which is
dnl    copyright (c) Janos Farkas and Stephan Kulow and licensed under
dnl    the LGPL.
dnl
dnl    Tests to see whether the current compiler supports the given flag.
dnl    The leading - should not be supplied.
dnl
dnl    Example: REGINA_CHECK_COMPILER_FLAG(Wall, [CXXFLAGS="$CXXFLAGS -Wall"])
dnl
AC_DEFUN([REGINA_CHECK_COMPILER_FLAG], [
  AC_MSG_CHECKING([whether $CXX supports -$1])
  __check_flag_save_cxxflags="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -$1"
  AC_TRY_COMPILE([], [return 0;], [
    AC_MSG_RESULT([yes])
    CXXFLAGS="$__check_flag_save_cxxflags"
    ifelse([$2], , :, [$2])
  ], [
    AC_MSG_RESULT([no])
    CXXFLAGS="$__check_flag_save_cxxflags"
    ifelse([$3], , :, [$3])
  ])
])

dnl
dnl    REGINA_CHECK_KDE_MODULEDIR
dnl
dnl    Runs a sanity check on the current $kde_moduledir.  In addition
dnl    the current $prefix, $kde_libs_prefix and $kde_moduledir are expanded
dnl    to full paths and displayed to the user.
dnl
dnl    If the $kde_moduledir does not look like it indeed contains
dnl    KDE modules, this routine generates an error with a detailed
dnl    explanation.
dnl
dnl    Passing the option --disable-moduledir-test will downgrade this
dnl    error to a warning so that the configure script can continue on
dnl    regardless.
dnl
dnl    Example: REGINA_CHECK_KDE_MODULEDIR
dnl
AC_DEFUN([REGINA_CHECK_KDE_MODULEDIR], [
  AC_ARG_ENABLE(moduledir-test, AC_HELP_STRING([--disable-moduledir-test],
      [skip the sanity check on $kde_moduledir]), [
    if test "$enableval" = "no"; then
      __skip_moduledir_test=yes
    fi
  ])

  # Run a sanity check on the prefixes.
  AS_AC_EXPAND(__expanded_prefix, [\$prefix])
  AS_AC_EXPAND(__expanded_kde_libs_prefix, [\$kde_libs_prefix])
  AS_AC_EXPAND(__expanded_kde_moduledir, [\$kde_moduledir])
  AC_MSG_NOTICE([using prefix $__expanded_prefix])
  AC_MSG_NOTICE([using kde_libs_prefix $__expanded_kde_libs_prefix])
  AC_MSG_NOTICE([using kde_moduledir $__expanded_kde_moduledir])

  AC_MSG_CHECKING([for a sensible \$kde_moduledir])
  if test -e "$__expanded_kde_moduledir/libkatepart.so"; then
    AC_MSG_RESULT([yes])
  else
    AC_MSG_RESULT([no])
    if test "$__skip_moduledir_test" = "yes"; then
      AC_MSG_WARN([The KDE module directory does not appear to contain libkatepart.so.])
    else
      cat <<END

The KDE module directory does not appear to contain libkatepart.so.
This is probably because the wrong installation prefix is being used.
It is essential to build Regina with the correct prefix; otherwise it
will not be able to run properly.

If the module directory $__expanded_kde_moduledir is correct and you
simply don't have the kate part installed (i.e., other KDE modules are
properly installed in $__expanded_kde_moduledir on your system), you
can rerun this configure script with the option --disable-moduledir-test
and it will skip over this test.

If the module directory $__expanded_kde_moduledir is incorrect (i.e.,
it does not contain KDE modules and/or libkatepart.so is installed
elsewhere), you must rerun this configure script with a correct --prefix
option.  If you run "kde-config --prefix" from the command-line, it will
hopefully tell you what this correct prefix should be.

    example:~/source/regina> kde-config --prefix
    /usr
    example:~/source/regina> ./configure --prefix=/usr
    ...

Please feel free to write to regina-user@lists.sourceforge.net
for assistance.

END
      AC_MSG_ERROR([Stopping so that the installation prefix can be resolved.])
    fi
  fi
])

dnl
dnl    REGINA_CHECK_KDE_VERSION
dnl
dnl    Ensures that Regina is building against a new enough version of KDE.
dnl    If the current KDE version is too old, this routine generates a fatal
dnl    error.
dnl
dnl    Example: REGINA_CHECK_KDE_VERSION
dnl
AC_DEFUN([REGINA_CHECK_KDE_VERSION], [
  AC_MSG_CHECKING([for KDE newer than 3.1.90])
  AC_LANG_PUSH(C++)
  regina_save_cxxflags="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS $all_includes"
  AC_TRY_COMPILE([
    #include <kdeversion.h>
  ], [
    #if ! (KDE_IS_VERSION(3, 1, 90))
    #error KDE_VERSION_TOO_OLD
    #endif
  ], [
    AC_MSG_RESULT([yes])
  ], [
    AC_MSG_RESULT([no])
    AC_MSG_ERROR([KDE version >= 3.1.90 is required.  Your version appears to be too old.])
  ])
  CXXFLAGS="$regina_save_cxxflags"
  AC_LANG_POP(C++)
])

dnl
dnl    REGINA_CHECK_LONG_LONG
dnl
dnl    Checks whether long long integers and 64-bit integer literals are valid.
dnl
dnl    AC_DEFINE()s the following variables:
dnl
dnl        HAVE_LONG_LONG: Defined as 1 if both signed and unsigned long long
dnl                        types are available, or remains undefined otherwise.
dnl        HAVE_NUMERIC_64: Defined as 1 if 64-bit integer literals with no
dnl                         L/LL suffix are vaild, or remains undefined
dnl                         otherwise.
dnl        HAVE_NUMERIC_64_LL: Defined as 1 if 64-bit integer literals with an
dnl                            LL suffix are valid, or remains undefined
dnl                            otherwise.
dnl
dnl    Example: REGINA_CHECK_LONG_LONG
dnl
AC_DEFUN([REGINA_CHECK_LONG_LONG], [
  AC_LANG_PUSH(C++)

  AC_MSG_CHECKING([for the long long integer type])
  AC_TRY_COMPILE([], [
    long long x;
    signed long long y;
    unsigned long long z;
  ], [
    AC_MSG_RESULT([yes])
    AC_DEFINE(HAVE_LONG_LONG, 1,
      [Define to 1 if both signed and unsigned long long types are available.])
  ], [
    AC_MSG_RESULT([no])
  ])

  AC_MSG_CHECKING([for 64-bit integer literals with no suffix])
  AC_TRY_COMPILE([], [
    0xFFFFFFFFFFFFFFFF;
  ], [
    AC_MSG_RESULT([yes])
    AC_DEFINE(HAVE_NUMERIC_64, 1,
      [Define to 1 if 64-bit integer literals are available with no suffix])
  ], [
    AC_MSG_RESULT([no])
  ])

  AC_MSG_CHECKING([for 64-bit integer literals with the LL suffix])
  AC_TRY_COMPILE([], [
    0xFFFFFFFFFFFFFFFFLL;
  ], [
    AC_MSG_RESULT([yes])
    AC_DEFINE(HAVE_NUMERIC_64_LL, 1,
      [Define to 1 if 64-bit integer literals are available using the LL suffix])
  ], [
    AC_MSG_RESULT([no])
  ])

  AC_LANG_POP(C++)
])

dnl
dnl    REGINA_CXX_PARTIAL_SPECIALISATION
dnl
dnl    Ensures that the C++ compiler supports partial specialisation.
dnl
dnl    Modified from AC_CXX_PARTIAL_SPECIALIZATION which is
dnl    copyright (c) Luc Maisonobe and licensed under the GPL.
dnl
AC_DEFUN([REGINA_CXX_PARTIAL_SPECIALISATION], [
  AC_MSG_CHECKING([whether the compiler supports partial specialisation])
  AC_LANG_PUSH(C++)
  AC_TRY_COMPILE([
    template<class T, int N> class A            { public : enum e { z = 0 }; };
    template<int N>          class A<double, N> { public : enum e { z = 1 }; };
    template<class T>        class A<T, 2>      { public : enum e { z = 2 }; };
  ], [
    return (A<int,3>::z == 0) && (A<double,3>::z == 1) && (A<float,2>::z == 2);
  ], [
    AC_MSG_RESULT([yes])
  ], [
    AC_MSG_RESULT([no])
    AC_MSG_ERROR([The C++ compiler does not support partial specialisation of templates.])
  ])
  AC_LANG_POP(C++)
])

dnl
dnl    REGINA_DO_NOT_COMPILE
dnl
dnl    Adds the given list of items to $DO_NOT_COMPILE.  Items already
dnl    listed in $DO_NOT_COMPILE will not be added again.
dnl
dnl    Example: REGINA_DO_NOT_COMPILE([DOCSMAN DOCSHTML])
dnl
AC_DEFUN([REGINA_DO_NOT_COMPILE], [
  for item in $1; do
    ruled_out="no"
    for j in $DO_NOT_COMPILE; do
      if test "$j" = "$item"; then
        ruled_out="yes"
        break
      fi
    done
    if test "$ruled_out" = "no"; then
      DO_NOT_COMPILE="$DO_NOT_COMPILE $item"
    fi
  done
])

dnl
dnl    REGINA_ERR_MISSING(MISSING-ITEM, REQUIRED-BY)
dnl
dnl    Quits with an error stating what was missing and which
dnl    build component requires it.
dnl
dnl    Example: REGINA_ERR_MISSING(Library libgmp, [the calculation engine])
dnl
AC_DEFUN([REGINA_ERR_MISSING], [
  AC_MSG_ERROR([[$1 is unavailable; this is needed by $2.]])
])

dnl
dnl    REGINA_FOLLOW_SYMLINKS(PATH)
dnl
dnl    Modified from _ACJNI_FOLLOW_SYMLINKS which is
dnl    copyright (c) Don Anderson and licensed under the GPL.
dnl
dnl    TODO: This macro does *not* deal with relative symlinks correctly.
dnl
dnl    Follows a chain of symlinks beginning with <PATH>, finally setting
dnl    variable _SYMLINKS_FOLLOWED to the real file or directory at the
dnl    end of this chain.
dnl
dnl    Note that <PATH> may be a real file or directory to begin with.
dnl
AC_DEFUN([REGINA_FOLLOW_SYMLINKS], [
  _cur="$1"
  while ls -ld "$_cur" 2> /dev/null | grep " -> " > /dev/null; do
    _slink=`ls -ld "$_cur" | sed 's/^.* -> //'`
    case "$_slink" in
      /* )
        _cur="$_slink"
        ;;
      * )
        # 'X' avoids triggering unwanted echo options.
        _cur=`echo "X$_cur" | sed -e 's/^X//' -e 's:[[^/]]*$::'`"$_slink"
        ;;
    esac
  done
  _SYMLINKS_FOLLOWED="$_cur"
])

dnl
dnl    REGINA_HEADER_OPTIONAL(HEADER, TARGET-LIST, REQUIRED-BY)
dnl
dnl    Checks for the given optional header.
dnl    Issues a warning and adds <TARGET-LIST> (which may consist of
dnl    several targets) to $DO_NOT_COMPILE if the header is missing.
dnl
dnl    Example: REGINA_HEADER_OPTIONAL(popt.h, UTILS, [command-line utilities])
dnl
AC_DEFUN([REGINA_HEADER_OPTIONAL], [
  AC_CHECK_HEADERS([$1], , [
    REGINA_WARN_MISSING([Header $1], [$3])
    REGINA_DO_NOT_COMPILE([$2])
  ])
])

dnl
dnl    REGINA_HEADER_REQUIRED(HEADER, REQUIRED-BY)
dnl
dnl    Checks for the given mandatory header.
dnl    Quits with an error message if the header is missing.
dnl
dnl    Example: REGINA_HEADER_REQUIRED(pthread.h, [the calculation engine])
dnl
AC_DEFUN([REGINA_HEADER_REQUIRED], [
  AC_CHECK_HEADERS([$1], , [
    REGINA_ERR_MISSING([Header $1], [$2])
  ])
])

dnl
dnl    REGINA_LD_ADD_STDCALL_ALIAS
dnl
dnl    Checks whether the linker supports --add-stdcall-alias.  This
dnl    flag may be needed for building JNI modules.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        ADD_STDCALL_ALIAS: The flag to include in LDFLAGS if
dnl                           --add-stdcall-alias is supported, or
dnl                           the empty string otherwise.
dnl
AC_DEFUN([REGINA_LD_ADD_STDCALL_ALIAS], [
  AC_MSG_CHECKING([whether the linker supports --add-stdcall-alias])

  __stdcall_save_ldflags="$LDFLAGS"
  LDFLAGS="$LDFLAGS -Wl,--add-stdcall-alias"
  AC_TRY_LINK([
    #include <cstdlib>
  ], [
    exit(0);
  ], [
    ADD_STDCALL_ALIAS="-Wl,--add-stdcall-alias"
    AC_MSG_RESULT([yes])
  ], [
    ADD_STDCALL_ALIAS=
    AC_MSG_RESULT([no])
  ])
  LDFLAGS="$__stdcall_save_ldflags"

  AC_SUBST(ADD_STDCALL_ALIAS)
])

dnl
dnl    REGINA_LIB_BOOST_PYTHON(TARGET-LIST, REQUIRED-BY)
dnl
dnl    Checks for a usable boost.python installation.
dnl    Issues a warning and adds <TARGET-LIST> (which may consist of
dnl    several targets) to $DO_NOT_COMPILE if boost.python is missing.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        BOOST_PYTHON_INCLUDES: The compiler flags required for
dnl                               building against boost.python,
dnl                               including flags for building against
dnl                               python itself.
dnl        BOOST_PYTHON_LIBS: The linker flags required for building
dnl                           against boost.python.
dnl        PYTHON_LIBS: The linker flags required for building against
dnl                     python itself.
dnl
dnl    AC_DEFINE()s the following variables:
dnl
dnl        HAVE_BOOST_PYTHON: Defined as 1 if we have a usable boost.python
dnl                           installation, or remains undefined otherwise.
dnl
dnl    Example: REGINA_LIB_BOOST_PYTHON(PYTHON, [the Python interface])
dnl
AC_DEFUN([REGINA_LIB_BOOST_PYTHON], [
  AC_LANG_PUSH(C++)

  AC_ARG_WITH(python-version, AC_HELP_STRING([--with-python-version=VER],
      [build against the given python version (e.g., 2.3)]), [
    pyversionlist=none
    if test "x$withval" != "xno"; then
      if test "x$withval" != "x"; then
        pyversionlist="python$withval python"
      fi
    fi
  ], [
    pyversionlist=none
  ])
  if test "x$pyversionlist" = "xnone"; then
    pyversionlist="python python2.6 python2.5 python2.4 python2.3 python2.2"
  fi

  AC_ARG_WITH(boost-suffix, AC_HELP_STRING([--with-boost-suffix=SUFFIX],
      [link against the boost libraries with the given suffix (e.g., gcc-mt-1_32)]), [
    boostliblist=none
    if test "x$withval" != "xno"; then
      if test "x$withval" != "x"; then
        boostliblist="boost_python-$withval boost_python-mt boost_python"
      fi
    fi
  ], [
    boostliblist=none
  ])
  if test "x$boostliblist" = "xnone"; then
    boostliblist="boost_python-mt boost_python boost_python-gcc-mt-1_33_1 boost_python-gcc-mt-1_32 boost_python-gcc-mt-1_31"
  fi

  AC_CHECK_HEADERS([boost/shared_ptr.hpp], [
    __regina_py_save_cxxflags="$CXXFLAGS"
    __regina_py_save_ldflags="$LDFLAGS"
    __regina_py_save_libs="$LIBS"
    __regina_py_ok=0
    for pyver in $pyversionlist; do
      for incdir in "/usr/include/$pyver" "/usr/local/include/$pyver" \
          "/usr/$pyver/include" "/usr/local/$pyver/include" \
          "$prefix/include/$pyver" "$prefix/$pyver/include"; do
        CXXFLAGS="$__regina_py_save_cxxflags -I$incdir"
        LDFLAGS="$__regina_py_save_ldflags -shared"

        # Check for python includes.
        AC_TRY_COMPILE([
          #include <Python.h>
        ], [
          PyObject obj;
        ], [
          # Check for compatibility with boost.python.
          AC_MSG_CHECKING([for boost.python with $incdir/Python.h])
          AC_TRY_COMPILE([
            #include <boost/python.hpp>
            const char* greet() { return "Hello world!"; }
            BOOST_PYTHON_MODULE(hello) { boost::python::def("greet", greet); }
          ], [
            /* No main body. */
          ], [
            AC_MSG_RESULT([yes])

            # Check for -lpython.
            for pylib in "$pyver" $pyversionlist; do
              for pylibdir in /usr/lib /usr/local/lib \
                  "/usr/lib/$pyver/config" "/usr/local/lib/$pyver/config" \
                  "$prefix/lib" "$prefix/lib/$pyver/config"; do
                for extralibs in "" "-lpthread -lm -lutil -ldl"; do
                  if test "x$extralibs" = "x"; then
                    extralibsmsg=""
                  else
                    extralibsmsg=" with $extralibs"
                  fi
                  AC_MSG_CHECKING([for lib$pylib in $pylibdir$extralibsmsg])
                  LDFLAGS="$__regina_py_save_ldflags -L$pylibdir"
                  LIBS="-l$pylib $extralibs"
                  AC_TRY_LINK([
                    #include <Python.h>
                  ], [
                    Py_Initialize(); Py_Finalize();
                  ], [
                    AC_MSG_RESULT([yes])

                    # Finally check for -lboost_python.
                    for boostlib in $boostliblist; do
                      AC_MSG_CHECKING([for lib$boostlib])
                      LIBS="-l$boostlib -l$pylib $extralibs"
                      AC_TRY_LINK([
                        #include <boost/python.hpp>
                        const char* greet() { return "Hello world!"; }
                        BOOST_PYTHON_MODULE(hello) {
                          boost::python::def("greet", greet);
                        }
                      ], [
                        Py_Initialize(); Py_Finalize();
                      ], [
                        AC_MSG_RESULT([yes])
                        # And we're done!
                        BOOST_PYTHON_INCLUDES="-I$incdir"
                        BOOST_PYTHON_LIBS="-l$boostlib -l$pylib $extralibs -L$pylibdir"
                        __regina_py_ok=1
                      ], [
                        AC_MSG_RESULT([no])
                      ])
                      if test "$__regina_py_ok" = "1"; then break; fi
                    done
                  ], [
                    AC_MSG_RESULT([no])
                  ])
                  if test "$__regina_py_ok" = "1"; then break; fi
                done
                if test "$__regina_py_ok" = "1"; then break; fi
              done
              if test "$__regina_py_ok" = "1"; then break; fi
            done
          ], [
            AC_MSG_RESULT([no])
          ])
        ])
        if test "$__regina_py_ok" = "1"; then break; fi
      done
      if test "$__regina_py_ok" = "1"; then break; fi
    done

    CXXFLAGS="$__regina_py_save_cxxflags"
    LDFLAGS="$__regina_py_save_ldflags"
    LIBS="$__regina_py_save_libs"

    if test "$__regina_py_ok" = "1"; then
      AC_DEFINE(HAVE_BOOST_PYTHON, 1,
        [Define to 1 if you have a usable boost.python installation.])
    else
      BOOST_PYTHON_INCLUDES=
      BOOST_PYTHON_LIBS=
      REGINA_WARN_MISSING([A working boost.python installation], [$2])
      REGINA_DO_NOT_COMPILE([$1])
    fi
  ], [
    REGINA_WARN_MISSING([A working boost installation], [$2])
    REGINA_DO_NOT_COMPILE([$1])
  ])
  AC_LANG_POP(C++)
  AC_SUBST(BOOST_PYTHON_INCLUDES)
  AC_SUBST(BOOST_PYTHON_LIBS)
])

dnl
dnl    REGINA_LIB_OPTIONAL(LIBNAME, FUNCTION-IN-LIB, FLAGSET,
dnl        TARGET-LIST, REQUIRED-BY)
dnl
dnl    Checks for the given optional library.
dnl    Issues a warning and adds <TARGET-LIST> (which may consist of
dnl    several targets) to $DO_NOT_COMPILE if the library is missing.
dnl    Adds -l<LIBNAME> to $<FLAGSET> if the library was found.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        <FLAGSET>: As described above; this is only set if the library
dnl                   was found.
dnl
dnl    Example: REGINA_LIB_OPTIONAL(popt, poptGetContext, UTILS_LIBS,
dnl                 UTILS, [command-line utilities])
dnl
AC_DEFUN([REGINA_LIB_OPTIONAL], [
  AC_CHECK_LIB([$1], [$2], [
    $3="-l$1"
    AC_SUBST([$3])
  ], [
    REGINA_WARN_MISSING([Library lib$1], [$5])
    REGINA_DO_NOT_COMPILE([$4])
  ])
])

dnl
dnl    REGINA_LIB_REQUIRED(LIBNAME, FUNCTION-IN-LIB, REQUIRED-BY)
dnl
dnl    Checks for the given mandatory library.
dnl    Quits with an error message if the library is missing.
dnl
dnl    Example: REGINA_LIB_REQUIRED(z, zlibVersion, [the calculation engine])
dnl
AC_DEFUN([REGINA_LIB_REQUIRED], [
  AC_CHECK_LIB([$1], [$2], , [
    REGINA_ERR_MISSING([Library lib$1], [$3])
  ])
])

dnl
dnl    REGINA_LIBTOOL_SHLIBS_REQUIRED(REQUIRED-BY, FLAG-TO-AVOID-REQ)
dnl
dnl    Verifies that libtool is configured with shared libraries enabled.
dnl    Quits with an informative error message otherwise.
dnl
dnl    Example: REGINA_LIBTOOL_SHLIBS_REQUIRED([the KDE user interface],
dnl        [--disable-kdeui])
dnl
AC_DEFUN([REGINA_LIBTOOL_SHLIBS_REQUIRED], [
  if test "x$enable_shared" != "xyes"; then
    cat <<END

Shared libraries are currently disabled.  They are however needed by
$1.

You can enable shared libraries by passing --enable-shared to this
configure script.  Alternatively, you can pass $2 to
disable $1.

Please feel free to write to regina-user@lists.sourceforge.net
for assistance.

END
    AC_MSG_ERROR([Stopping so that this problem can be resolved.])
  fi
])

dnl
dnl    REGINA_PACKAGE_VERSIONS
dnl
dnl    Extracts major and minor version numbers from $PACKAGE_VERSION.
dnl
dnl    Variable $PACKAGE_VERSION must contain a set of components
dnl    separated by periods (such as 2.3.1).  The first two of these
dnl    components are defined to be the major and minor versions
dnl    respectively, and must be integers.
dnl
dnl    AC_DEFINE()s the following integer variables:
dnl
dnl        PACKAGE_VERSION_MAJOR: The extracted major version.
dnl        PACKAGE_VERSION_MINOR: The extracted minor version.
dnl
AC_DEFUN([REGINA_PACKAGE_VERSIONS], [
  PACKAGE_VERSION_MAJOR=`echo "$PACKAGE_VERSION" | \
    sed -e 's#\..*##'`
  PACKAGE_VERSION_MINOR=`echo "$PACKAGE_VERSION" | \
    sed -e 's#^[0-9]*\.##' | sed -e 's#\..*##'`
  AC_DEFINE_UNQUOTED(PACKAGE_VERSION_MAJOR, [$PACKAGE_VERSION_MAJOR],
    [Major version number of the package.])
  AC_DEFINE_UNQUOTED(PACKAGE_VERSION_MINOR, [$PACKAGE_VERSION_MINOR],
    [Minor version number of the package.])
])

dnl
dnl    REGINA_PROG_OPTIONAL(PROG-LIST, VARIABLE, DESCRIPTION, TARGET-LIST,
dnl        REQUIRED-BY)
dnl
dnl    Checks for the given optional program.  The first program from
dnl    <PROG-LIST> that is found will be used.  Alternatively the user
dnl    can override this list by setting <VARIABLE> in the environment.
dnl
dnl    Issues a warning and adds <TARGET-LIST> (which may consist of
dnl    several targets) to $DO_NOT_COMPILE if the program is missing.
dnl
dnl    Variable <VARIABLE> is defined as precious with the help
dnl    text <DESCRIPTION>.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        <VARIABLE>: The program from the given list that was found,
dnl                    or an appropriate invocation of "missing" if
dnl                    no program was found.
dnl
dnl    Example: REGINA_PROG_OPTIONAL(doxygen, DOXYGEN,
dnl                 [Doxygen command for C++ source documentation], DOCSENGINE,
dnl                 [calculation engine documentation])
dnl
AC_DEFUN([REGINA_PROG_OPTIONAL], [
  AC_ARG_VAR([$2], [$3])
  AC_CHECK_PROGS([$2], [$1], none)
  if test "$$2" = "none"; then
    REGINA_DO_NOT_COMPILE([$4])
    for first_prog in $1; do break; done
    AC_SUBST([$2], ["\$(top_srcdir)/admin/missing $first_prog"])
    REGINA_WARN_MISSING([Program $first_prog], [$5])
  fi
])

dnl
dnl    REGINA_SHOULD_BUILD(ITEM, VALUE, DESCRIPTION)
dnl
dnl    Checks whether ITEM is listed in $DO_NOT_COMPILE.
dnl    The given description will be used in the corresponding
dnl    configuration progress message.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        REGINA_BUILD_<ITEM>: <VALUE> if ITEM should be built,
dnl                             empty otherwise.
dnl
dnl    Example: REGINA_SHOULD_BUILD(DOCSHTML, html, [the reference manual])
dnl
AC_DEFUN([REGINA_SHOULD_BUILD], [
  AC_MSG_CHECKING([whether to build $3])
  REGINA_SHOULD_BUILD_INTERNAL([$1])
  AC_MSG_RESULT([$should_build])
  if test "$should_build" = "yes"; then
    REGINA_BUILD_$1="$2"
  else
    REGINA_BUILD_$1=
  fi
  AC_SUBST(REGINA_BUILD_$1)
])

dnl
dnl    REGINA_SHOULD_BUILD_INTERNAL(ITEM)
dnl
dnl    Checks whether ITEM is listed in $DO_NOT_COMPILE.
dnl    Variable $should_build will be set to "yes" or "no" as appropriate.
dnl
AC_DEFUN([REGINA_SHOULD_BUILD_INTERNAL], [
  should_build="yes"
  for j in $DO_NOT_COMPILE; do
    if test "$j" = "$1"; then
      should_build="no"
    fi
  done
])

dnl
dnl    REGINA_TYPE_HASH_SET
dnl
dnl    Determines characteristics of class hash_set<...> from the
dnl    Standard Template Library.
dnl
dnl    AC_SUBST()s the following variables:
dnl
dnl        HASH_SET_HEADER: The header file containing class hash_set<...>.
dnl
dnl    AC_DEFINE()s the following variables:
dnl
dnl        __HASH_NAMESPACE: The namespace containing class hash_set<...>.
dnl        __NO_NAMESPACE_ALIASES: 1 if namespace std cannot be alised,
dnl                                0 otherwise.
dnl
AC_DEFUN([REGINA_TYPE_HASH_SET], [
  AC_LANG_PUSH(C++)

  # Search for the hash_set header.
  HASH_SET_HEADER=
  AC_CHECK_HEADERS([ext/hash_set hash_set], [
    HASH_SET_HEADER="$ac_header"
    break
  ])
  if test -z "$HASH_SET_HEADER"; then
    AC_MSG_ERROR([[The hash_set headers could not be found.]])
  fi
  AC_SUBST(HASH_SET_HEADER)

  # Determine which namespace the hash_set template is in.
  AC_MSG_CHECKING([[hash_set namespace]])
  HASH_SET_NAMESPACE=none
  for i in std __gnu_cxx; do
    echo "#include <$HASH_SET_HEADER>" > conftest.$ac_ext
    echo "$i::hash_set<int> set;" >> conftest.$ac_ext
    ac_compile='${CXX-g++} -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext'
    if AC_TRY_EVAL(ac_compile); then
      HASH_SET_NAMESPACE="$i"
      break
    fi
  done
  AC_MSG_RESULT([$HASH_SET_NAMESPACE])
  if test "$HASH_SET_NAMESPACE" = "none"; then
    AC_MSG_ERROR([[The namespace for class hash_set<...> could not be determined.]])
  fi
  AC_DEFINE_UNQUOTED(__HASH_NAMESPACE, [$HASH_SET_NAMESPACE],
    [Namespace for class hash_set<...>.])

  # Determine whether we can alias a namespace to std.
  AC_MSG_CHECKING([[whether namespace std can be aliased]])
  echo "#include <$HASH_SET_HEADER>" > conftest.$ac_ext
  echo "namespace stdalias = $HASH_SET_NAMESPACE;" >> conftest.$ac_ext
  echo "stdalias::hash_set<int> s;" >> conftest.$ac_ext
  ac_compile='${CXX-g++} -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext'
  if AC_TRY_EVAL(ac_compile); then
    AC_MSG_RESULT([yes])
    NO_NAMESPACE_ALIASES=0
  else
    AC_MSG_RESULT([no])
    NO_NAMESPACE_ALIASES=1
  fi
  AC_DEFINE_UNQUOTED(__NO_NAMESPACE_ALIASES, [$NO_NAMESPACE_ALIASES],
    [Define to 1 if namespace std cannot be aliased.])

  AC_LANG_POP(C++)
])

dnl
dnl    REGINA_VAR_IOS_NOCREATE
dnl
dnl    Determines whether std::ios::nocreate is a valid file opening flag.
dnl
dnl    AC_DEFINE()s the following variables:
dnl
dnl        __USE_IOS_NOCREATE: 1 if this flag is valid, 0 otherwise.
dnl
AC_DEFUN([REGINA_VAR_IOS_NOCREATE], [
  AC_MSG_CHECKING([[for std::ios::nocreate]])
  AC_TRY_COMPILE([
    #include <fstream>
  ], [
    std::ifstream in("foo", std::ios::nocreate);
  ], [
    AC_MSG_RESULT([yes])
    USE_IOS_NOCREATE=1
  ], [
    AC_MSG_RESULT([no])
    USE_IOS_NOCREATE=0
  ])
  AC_DEFINE_UNQUOTED(__USE_IOS_NOCREATE, [$USE_IOS_NOCREATE],
    [Define to 1 if flag std::ios::nocreate is valid.])
])

dnl
dnl    REGINA_WARN_MISSING(MISSING-ITEM, REQUIRED-BY)
dnl
dnl    Issues a warning stating what was missing and which
dnl    build component requires it.
dnl
dnl    Example: REGINA_WARN_MISSING(Library libpopt, [command-line utilities])
dnl
AC_DEFUN([REGINA_WARN_MISSING], [
  AC_MSG_WARN([[$1 is unavailable; $2 will not be built.]])
])

