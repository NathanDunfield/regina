<reference id="utils">
 <title>Specialised Utilities</title>

 <partintro>
  <para>
   The main applications <command>regina-kde</command> and
   <command>regina-python</command> are documented in the
   <link linkend="manpages">previous reference chapter</link>.
   This reference chapter documents the remaining specialised command-line
   utilities that are provided with &regina;.
  </para>
 </partintro>

 <!-- File Concatenator -->

 <refentry id="man-regconcat">
  <refmeta>
   <refentrytitle>regconcat</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>regconcat</refname>
   <refpurpose>Combine several &regina; data files</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>regconcat</command>
    <arg><option>-o</option> <replaceable>output-file</replaceable></arg>
    <arg rep="repeat" choice="req"><replaceable>input-file</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    This utility combines several individual &regina; data files into
    a single larger data file.  The new file will have a container as its
    top-level packet, beneath which will be placed the packet trees from
    each of the supplied input files.
   </para>
   <para>
    If an output file is specified through option <option>-o</option>,
    the new file will be written as compressed &xml; to this output file.
    Otherwise the new file will be written as uncompressed &xml; to
    standard output.
   </para>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <variablelist>
    <varlistentry>
     <term><option>-o</option> <replaceable>output-file</replaceable></term>
     <listitem>
      <para>
       Specifies that the new combined data file should be written
       as compressed &xml; to the given output file.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- File Converter -->

 <refentry id="man-regconvert">
  <refmeta>
   <refentrytitle>regconvert</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>regconvert</refname>
   <refpurpose>Convert between different &regina; file formats</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>regconvert</command>
    <group>
     <arg><option>-x</option></arg>
     <arg><option>-u</option></arg>
     <arg><option>-b</option></arg>
    </group>
    <arg choice="req"><replaceable>old-file</replaceable></arg>
    <arg><replaceable>new-file</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Between &regina; versions 2.4 and 3.0, the data files changed from
    using an impenetrable and undocumented binary format to using
    (optionally compressed) &xml;.
   </para>
   <para>
    This utility simply converts back and forth between these different
    file formats.
   </para>
   <para>
    Argument <replaceable>old-file</replaceable> should be the file to
    read and convert; argument <replaceable>new-file</replaceable> should
    be the name of the new converted file to write.  These two filenames
    may be the same, in which case the old file will be replaced with the new.
   </para>
   <para>
    If argument <replaceable>new-file</replaceable> is missing, the new
    file will be written to standard output; this forces output to be
    uncompressed &xml; (see option <option>-u</option>).
   </para>
   <warning><para>
    When writing an old-style binary file, some information might be
    lost.  Specifically, only information that is understood by the
    &regina;&nbsp;2.4 calculation engine will be written.
   </para></warning>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <variablelist>
    <varlistentry>
     <term><option>-x</option> (default)</term>
     <listitem>
      <para>Convert to compressed &xml;.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-u</option></term>
     <listitem>
      <para>Convert to plain (uncompressed) &xml;.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-b</option></term>
     <listitem>
      <para>Convert to the old-style binary format.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regfiletype">regfiletype</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- File Dumper -->

 <refentry id="man-regfiledump">
  <refmeta>
   <refentrytitle>regfiledump</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>regfiledump</refname>
   <refpurpose>Dump the contents of a &regina; data file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>regfiledump</command>
    <group>
     <arg><option>-f</option></arg>
     <arg><option>-l</option></arg>
     <arg><option>-n</option></arg>
    </group>
    <arg><option>-c</option></arg>
    <arg choice="req"><replaceable>file</replaceable></arg>
    <arg rep="repeat"><replaceable>packet-label</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    This utility dumps the contents of the given &regina; data file to
    standard output in a human-readable format.
   </para>
   <para>
    If a list of packet labels is given on the command-line, only those
    packets listed will be output.  Otherwise all packets in the given
    file will be output.
   </para>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <variablelist>
    <varlistentry>
     <term><option>-f</option> (default)</term>
     <listitem>
      <para>
       Output full packet details.  Output for each packet will cover
       several lines, beginning with basic packet details (such as label
       and type) followed by the packet's long description.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-l</option></term>
     <listitem>
      <para>
       Output a list of packet labels and types only, one packet per line.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-n</option></term>
     <listitem>
      <para>
       Don't output any packets at all; this option forces a packet
       count (see option <option>-c</option>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-c</option></term>
     <listitem>
      <para>Finish output with a count of all packets in the given file.</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  &submani18n;

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- File Identifier -->

 <refentry id="man-regfiletype">
  <refmeta>
   <refentrytitle>regfiletype</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>regfiletype</refname>
   <refpurpose>Identify the formats of &regina; data files</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>regfiletype</command>
    <arg choice="req" rep="repeat"><replaceable>file</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Between &regina; versions 2.4 and 3.0, the data files changed from
    using an impenetrable and undocumented binary format to using
    (optionally compressed) &xml;.
   </para>
   <para>
    This utility simply determines which of these formats a given
    &regina; data file is in.
   </para>
   <para>
    Multiple files may be given on the command-line; the details of each
    file format will be written to standard output.
   </para>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regconvert">regconvert</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- Signature Census -->

 <refentry id="man-sigcensus">
  <refmeta>
   <refentrytitle>sigcensus</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>sigcensus</refname>
   <refpurpose>Form a census of splitting surface signatures</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>sigcensus</command>
    <arg choice="req"><replaceable>order</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Forms a census of all splitting surface signatures of the given
    order (the <firstterm>order</firstterm> is the number of quads in
    the resulting splitting surface).
   </para>
   <para>
    The signatures will be written to standard output, one per
    line, followed by a count of the total number of signatures found.
   </para>
   <para>
    Each signature will be output precisely once up to equivalence.
    Signatures are considered equivalent if they are related by some
    combination of:
    <itemizedlist>
     <listitem>
      <para>relabelling symbols;</para>
     </listitem>
     <listitem>
      <para>rotating an individual cycle;</para>
     </listitem>
     <listitem>
      <para>inverting an individual cycle (i.e., reversing the cycle and
       changing the case of each symbol in the cycle);</para>
     </listitem>
     <listitem>
      <para>reversing all cycles without changing the case of any
       symbols.</para>
     </listitem>
    </itemizedlist>
   </para>
   <warning><para>
    Currently upper-case symbols in signatures are not supported; this
    program will only output signatures whose symbols are all lower-case.
    Hopefully this deficiency will be removed in future versions.
   </para></warning>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-tricensus">tricensus</link>,
    <link linkend="man-tricensus-manager">tricensus-manager</link>,
    <link linkend="man-tricensus-mpi">tricensus-mpi</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- Triangulation Census -->

 <refentry id="man-tricensus">
  <refmeta>
   <refentrytitle>tricensus</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>tricensus</refname>
   <refpurpose>Form a census of 3-manifold triangulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>tricensus</command>
    <arg><option>-t, --tetrahedra=</option><replaceable>tetrahedra</replaceable></arg>
    <group>
     <arg><option>-b, --boundary</option></arg>
     <arg><option>-i, --internal</option></arg>
     <arg><option>-B, --bdryfaces=</option><replaceable>faces</replaceable></arg>
    </group>
    <group>
     <arg><option>-o, --orientable</option></arg>
     <arg><option>-n, --nonorientable</option></arg>
    </group>
    <group>
     <arg><option>-f, --finite</option></arg>
     <arg><option>-d, --ideal</option></arg>
    </group>
    <group>
     <arg><option>-m, --minimal</option></arg>
     <arg><option>-M, --minprime</option></arg>
     <arg><option>-N, --minprimep2</option></arg>
    </group>
    <group>
     <arg><option>-p, --genpairs</option></arg>
     <arg><option>-P, --usepairs</option></arg>
    </group>
    <arg choice="req"><replaceable>output-file</replaceable></arg>
   </cmdsynopsis>
   <cmdsynopsis>
    <command>tricensus</command>
    <arg choice="req"><option>--help</option></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Forms a census of all 3-manifold triangulations satisfying a
    particular set of conditions.
   </para>
   <para>
    The only condition that must be provided is the number of tetrahedra
    used to build the triangulations.  Additional constraints may be
    specified on the command-line as described below.
   </para>
   <para>
    Each triangulation will be output precisely once up to combinatorial
    isomorphism.  Invalid triangulations (triangulations with edges
    identified to themselves in reverse or boundary vertices whose links
    are not discs) will not be output at all.
   </para>
   <para>
    As the census progresses, the state of progress will be written (slowly)
    to standard output.  Once the census is complete, the census itself will
    be saved to the given file.
   </para>
   <para>
    Note that options <option>--genpairs</option> and
    <option>--usepairs</option> may be used to split a census into smaller
    pieces to be run simultaneously on different machines.  See also the
    <link
     linkend="man-tricensus-manager"><command>tricensus-manager</command></link>
    and
    <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
    utilities, which can help coordinate these simultaneous processes.
   </para>
   <warning><para>
    A census with even a relatively small number of tetrahedra can
    take an incredibly long time to run and chew up massive amounts of
    memory.  It is recommended that you try very small censuses to begin
    with (such as 3 or 4 tetrahedra) and work upwards to establish the
    limits relative to your machine.
   </para></warning>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <variablelist>
    <varlistentry>
     <term><option>-t,
      --tetrahedra=</option><replaceable>tetrahedra</replaceable></term>
     <listitem>
      <para>
       Specifies the number of tetrahedra used to build the triangulations.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-b, --boundary</option></term>
     <listitem>
      <para>
       Only produce triangulations with at least one boundary face.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-i, --internal</option></term>
     <listitem>
      <para>
       Only produce triangulations with all faces internal (i.e., with no
       boundary faces).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-B,
      --bdryfaces=</option><replaceable>faces</replaceable></term>
     <listitem>
      <para>
       Only produce triangulations with the precise number of boundary
       faces specified.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-o, --orientable</option></term>
     <listitem>
      <para>
       Only produce orientable triangulations.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-n, --nonorientable</option></term>
     <listitem>
      <para>
       Only produce non-orientable triangulations.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-f, --finite</option></term>
     <listitem>
      <para>
       Only produce finite triangulations (triangulations with no
       ideal vertices).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-d, --ideal</option></term>
     <listitem>
      <para>
       Only produce triangulations with at least one ideal vertex.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-m, --minimal</option></term>
     <listitem>
      <para>
       Do not include triangulations that are obviously non-minimal.
      </para>
      <para>
       A series of short tests will be run on each triangulation produced;
       if a triangulation is found to be non-minimal it will not be placed
       in the census.
      </para>
      <para>
       Note that these tests are not capable of deciding that a
       triangulation <emphasis>is</emphasis> minimal; at best the results
       will be inconclusive (in which case the triangulation will be placed
       in the census anyway).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-M, --minprime</option></term>
     <listitem>
      <para>
       Do not include triangulations that are obviously non-minimal,
       non-prime and/or disc-reducible.
      </para>
      <para>
       This option can significantly speed up the census and vastly
       reduce the final number of triangulations produced.
      </para>
      <para>
       A triangulation satisfying any of the above conditions might be
       left out of the census, although not all such triangulations will
       be ignored.  What <emphasis>is</emphasis> guaranteed is that any
       triangulation that is minimal, prime and disc-irreducible will
       certainly be included in the census.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-N, --minprimep2</option></term>
     <listitem>
      <para>
       Do not include triangulations that are obviously non-minimal,
       non-prime, P2-reducible and/or disc-reducible.
      </para>
      <para>
       As with the <option>--minprime</option> option,
       this option can significantly speed up the census and vastly
       reduce the final number of triangulations produced.
      </para>
      <para>
       A triangulation satisfying any of the above conditions might be
       left out of the census, although not all such triangulations will
       be ignored.  What <emphasis>is</emphasis> guaranteed is that any
       triangulation that is minimal, prime, P2-irreducible and
       disc-irreducible will certainly be included in the census.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-p, --genpairs</option></term>
     <listitem>
      <para>
       Only generate face pairings, not triangulations.
      </para>
      <para>
       The outermost layer of the census code involves pairing off the
       faces of the individual tetrahedra without actually determining
       the corresponding gluing permutations.  For each face pairing
       produced, all possible sets of gluing permutations are then generated
       and corresponding triangulations created.
      </para>
      <para>
       Face pairing generation consumes a very small fraction of the
       total census runtime, and effectively divides the census into
       multiple pieces.  By using this option, one can quickly generate
       a complete list of possible face pairings and then feed subsets of
       this list to different machines to work on simultaneously in order
       to produce an overall census of triangulations.  See the
       <link linkend="man-tricensus-manager"><command>tricensus-manager</command></link>
       and
       <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
       utilities for assistance in coordinating these simultaneous processes.
      </para>
      <para>
       The list of all face pairings will be written to the given output
       file in text format (although in the special case of face pairing
       generation you may omit the output file from the command-line, in
       which case the pairings will be written to standard output).
       This program can then be run with option <option>--usepairs</option>
       to generate the actual triangulations corresponding to different
       subsets of these face pairings.
      </para>
      <para>
       Note that orientability, finiteness or minimality options may not be
       supplied with this option; they should instead be supplied when option
       <option>--usepairs</option> is used to process each subset of face
       pairings.
      </para>
      <para>
       Note also that when this option is used no progress reporting will
       take place (although the face pairings should be generated
       sufficiently quickly that the output file itself can be used to
       track the state of progress).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-P, --usepairs</option></term>
     <listitem>
      <para>
       Use only the given subset of face pairings to build the triangulations.
      </para>
      <para>
       Each face pairing that is processed <emphasis>must</emphasis> be
       in canonical form, i.e., must be a minimal representative of its
       isomorphism class.  Note that the face pairings generated by option
       <option>--genpairs</option> all satisfy this condition.
      </para>
      <para>
       Face pairings should be supplied on standard input, one per line.
       They should be listed in the format produced by option
       <option>--genpairs</option>.
      </para>
      <para>
       This option is used to run only a subset of a particular census.  See
       option <option>--genpairs</option> for further details on how to split
       a census into subsets to run simultaneously on different machines.
       See also the
       <link linkend="man-tricensus-manager"><command>tricensus-manager</command></link>
       and
       <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
       utilities, which can help coordinate these simultaneous processes.
      </para>
      <para>
       Note that tetrahedron or boundary options may not be supplied with
       this option; they should instead be supplied when option
       <option>--genpairs</option> is used to split the full census into
       pieces.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Examples</title>

   <para>
    The following command forms a census of all 3-tetrahedron closed
    non-orientable triangulations and puts the results in the file
    <filename>results.rga</filename>.  To ensure that triangulations are
    closed we use the options <option>-i</option> (no boundary faces)
    and <option>-f</option> (no ideal vertices).
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus -t 3 -nif results.rga</userinput>
    Progress reports are periodic.
    Not all face pairings used will be reported.
    0:1 0:0 1:0 1:1 | 0:2 0:3 2:0 2:1 | 1:2 1:3 2:3 2:2
    Finished.
    Total triangulations: 5
    <prompt>example$</prompt>
</screen>

   <para>
    The following command forms a census of 4-tetrahedron closed
    orientable triangulations, where the census creation is optimised
    for prime minimal triangulations.  Although all prime minimal
    triangulations will be included, there may be some non-prime or
    non-minimal triangulations that are left out.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus -t 4 -oifM results.rga</userinput>
    Progress reports are periodic.
    Not all face pairings used will be reported.
    0:1 0:0 1:0 1:1 | 0:2 0:3 2:0 2:1 | 1:2 1:3 3:0 3:1 | 2:2 ...
    1:0 1:1 2:0 3:0 | 0:0 0:1 2:1 3:1 | 0:2 1:2 3:2 3:3 | 0:3 ...
    Finished.
    Total triangulations: 17
    <prompt>example$</prompt>
</screen>

   <para>
    The following command generates all face pairings for a
    5-tetrahedron census where triangulations must have precisely two
    boundary faces.  The face pairings will be written to
    <filename>pairings.txt</filename>, whereupon they can be broken up
    and distributed for processing at a later date.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus --genpairs -t 5 -B 2 pairings.txt</userinput>
    Total face pairings: 118
    <prompt>example$</prompt>
</screen>

   <para>
    The face pairings generated in the previous example can then be fleshed
    out into a full census of all 3-manifold triangulations with five
    tetrahedra, precisely two boundary faces and no ideal vertices as
    follows.  Note that the number of tetrahedra and boundary faces were
    already specified in the previous command and do not need to be
    supplied again.  The face pairings will be read from
    <filename>pairings.txt</filename> and the final census will be
    written to <filename>results.rga</filename>.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus --usepairs -f results.rga &lt; pairings.txt</userinput>
    Trying face pairings...
    0:1 0:0 1:0 1:1 | 0:2 0:3 2:0 2:1 | 1:2 1:3 3:0 3:1 | 2:2 ...
    0:1 0:0 1:0 1:1 | 0:2 0:3 2:0 2:1 | 1:2 1:3 3:0 3:1 | 2:2 ...
    ...
    ... (running through all 118 face pairings)
    ...
    1:0 2:0 3:0 4:0 | 0:0 2:1 3:1 4:1 | 0:1 1:1 3:2 4:2 | 0:2 ...
    Total triangulations: 5817
    <prompt>example$</prompt>
</screen>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-sigcensus">sigcensus</link>,
    <link linkend="man-tricensus-manager">tricensus-manager</link>,
    <link linkend="man-tricensus-mpi">tricensus-mpi</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- Triangulation Census Manager (Shared Directory) -->

 <refentry id="man-tricensus-manager">
  <refmeta>
   <refentrytitle>tricensus-manager</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>tricensus-manager</refname>
   <refpurpose>Distribute a triangulation census amongst several machines</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>tricensus-manager</command>
    <group>
     <arg><option>-o, --orientable</option></arg>
     <arg><option>-n, --nonorientable</option></arg>
    </group>
    <group>
     <arg><option>-f, --finite</option></arg>
     <arg><option>-d, --ideal</option></arg>
    </group>
    <group>
     <arg><option>-m, --minimal</option></arg>
     <arg><option>-M, --minprime</option></arg>
     <arg><option>-N, --minprimep2</option></arg>
    </group>
    <arg choice="req"><replaceable>pairs-file-prefix</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Allows multiple processes, possibly running on different machines,
    to collaborate in forming a census of 3-manifold triangulations.
    Coordination is done through a simple locking of files in a shared
    directory, and each separate process must be started manually.
   </para>
   <note><para>
    This program makes no use of any formal cluster-like infrastructure.
    For an &mpi;-enabled program better suited to running on a cluster, see the
    <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
    utility instead.
   </para></note>
   <para>
    Census generation must take place in a single directory.  The
    different processes are coordinated by locking files in this
    directory, and progress reports and final results are stored in this
    directory also.  If the census is to be distributed amongst different
    machines (not just different processors), this directory must be on a
    filesystem to which they all have access.
   </para>
   <para>
    In preparing a census to be distributed amongst several processes or
    machines, it should first be split into several smaller pieces.
    Running <link linkend="man-tricensus"><command>tricensus</command></link>
    with option <option>--genpairs</option> (which is quite fast) will create
    a list of face pairings, each of which must be analysed in order to
    complete the census.  The census is split into pieces by subdividing
    this list of face pairings.
   </para>
   <note><para>
    Whereas <command>tricensus-manager</command>
    uses many small face pairings files (with individual processes
    claiming individual files to work on),
    the alternative <command>tricensus-mpi</command> uses a single large face
    pairings file (with &mpi; handling the distribution of pairings to
    individual processes).
   </para></note>
   <para>
    A common file prefix (such as <filename>6-or</filename>) should be
    selected.  Each subset of face pairings should be stored (one face
    pairing per line) in a file whose name begins with this prefix and
    ends with <filename>.pairs</filename>.  For instance, if
    <command>tricensus</command> with option <option>--genpairs</option>
    produced 10 face pairings, these might be split into five files, each
    with two lines representing two of these face pairings, named
    <filename>6-or-0.pairs</filename>, <filename>6-or-1.pairs</filename>,
    <filename>6-or-2.pairs</filename>, <filename>6-or-3.pairs</filename> and
    <filename>6-or-4.pairs</filename> respectively.
   </para>
   <warning>
    <para>
     Each face pairing that is processed <emphasis>must</emphasis> be
     in canonical form, i.e., must be a minimal representative of its
     isomorphism class.  Note that the face pairings generated by
     <link linkend="man-tricensus"><command>tricensus</command></link>
     with option <option>--genpairs</option> all satisfy this condition.
    </para>
   </warning>
   <para>
    The <command>tricensus-manager</command> utility works as follows.
    It runs through all files beginning with the given prefix and ending
    in <filename>.pairs</filename>, and assumes each of these contains a
    subset of face pairings to process.  If a pairings file has already been
    taken by another process (i.e., if a corresponding time file such as
    <filename>6-or-3.time</filename> exists), it will be skipped.
    Otherwise the pairings file will be claimed by this process and the
    following actions will be taken.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      This process will write its own time file (such as
      <filename>6-or-3.time</filename>) indicating which machine and
      which <command>tricensus-manager</command> process has claimed
      this particular subset of face pairings.
     </para>
    </listitem>
    <listitem>
     <para>
      Command <command>tricensus</command> will be run with this subset
      of face pairings to analyse (using option <option>--usepairs</option>).
      Any other options given on the <command>tricensus-manager</command>
      command-line will be passed directly through to
      <command>tricensus</command> (these might include orientability or
      minimality options, for instance).  The time at which this
      subcensus began will be noted in the time file.
     </para>
    </listitem>
    <listitem>
     <para>
      All output from the running subcensus will be redirected to a
      corresponding progress file (such as
      <filename>6-or-3.progress</filename>).  In particular, this allows
      the user at any given time to see which face pairings from this
      particular subset have been processed.
     </para>
    </listitem>
    <listitem>
     <para>
      When this particular subcensus is complete, the results will be
      saved in a corresponding topology data file (such as
      <filename>6-or-3.rga</filename>).  The time at which the subcensus
      finished will be noted in the time file.
     </para>
    </listitem>
    <listitem>
     <para>
      At this point <command>tricensus-manager</command> will move on
      and look for another subset of face pairings to process.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Each <command>tricensus-manager</command> process will have at most
    one child <command>tricensus</command> process running at any given
    time.  Thus, for instance, if you have nine machines (all with
    access to the common census directory) and you wish to have two
    census calculations running simultaneously on each of these
    machines, you should start <command>tricensus-manager</command>
    a total of 18 times, twice on each machine, each with an identical
    command-line.  These 18 simultaneous processes will then effectively
    divide up the overall census between them.
   </para>
   <para>
    Note that the number of face pairings files does not need to equal
    the number of processors.  In fact, it is generally good to have a
    very large number of small face pairings files (rather than a few
    larger face pairings files).  Different files may take significantly
    different times to process, and so by using many smaller files the
    workload can be distributed more evenly between the various processors.
   </para>
   <tip><para>
    Once the census is complete, the
    <link linkend="man-regconcat"><command>regconcat</command></link>
    command may be used to combine the many small topology data files
    into one larger file for easier handling.
   </para></tip>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <para>
    Any census options that are passed to
    <command>tricensus-manager</command> will be passed directly through to
    <command>tricensus</command>.  See the
    <link linkend="man-tricensus"><command>tricensus</command> reference</link>
    for details.
   </para>
   <para>
    Note that some <command>tricensus</command> options are not
    available here (e.g., tetrahedra and boundary options), since these must
    be supplied earlier on when generating the initial list of face pairings
    through <userinput>tricensus --genpairs</userinput>.
   </para>
   <para>
    The option <option>--usepairs</option> need not be given to
    <command>tricensus-manager</command>; this will be automatically
    supplied to each child <command>tricensus</command> process.
   </para>
   <para>
    Topology data output filenames must not be given to
    <command>tricensus-manager</command> since these differ for each
    subcensus.  Topology data filenames will be automatically
    derived and supplied to each child <command>tricensus</command> process.
   </para>
  </refsect1>

  <refsect1>
   <title>Examples</title>
   <para>
    Suppose we wish to form a census of all 5-tetrahedron closed
    non-orientable triangulations, where the census is optimised for
    prime minimal P2-irreducible triangulations (and in particular, some
    triangulations that are not prime, minimal and P2-irreducible may be
    left out).
   </para>
   <para>
    We begin by using <command>tricensus</command> to generate a full
    list of face pairings.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus --genpairs -t 5 -i &gt; 5.pairs</userinput>
    Total face pairings: 28
    <prompt>example$</prompt>
</screen>

   <para>
    We now split the large face pairings file into several smaller
    files, each containing 4 of the 28 pairings.  The
    <command>split</command> command is useful for this task.  Don't
    forget that these files <emphasis>must</emphasis> be renamed
    so that they end in the extension <filename>.pairs</filename>.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>split -l 4 5.pairs 5-nor</userinput>
    <prompt>example$</prompt> <userinput>ls</userinput>
    5-noraa  5-norab  5-norac  5-norad  5-norae  5-noraf  5-norag  5.pairs
    <prompt>example$</prompt> <userinput>prename 's/$/.pairs/' 5-nor*</userinput>
    <prompt>example$</prompt> <userinput>ls</userinput>
    5-noraa.pairs  5-norac.pairs  5-norae.pairs  5-norag.pairs
    5-norab.pairs  5-norad.pairs  5-noraf.pairs  5.pairs
    <prompt>example$</prompt>
</screen>

   <para>
    Finally, on each individual machine that will join in the
    computation, we use <command>tricensus-manager</command> to start a
    new process.  The remaining census options are passed here.
   </para>

<screen>
    <prompt>node_1$</prompt> <userinput>tricensus-manager -nfN 5-nor</userinput>
    Trying 5-noraa.pairs ... taken and processing ...
</screen>

<screen>
    <prompt>node_2$</prompt> <userinput>tricensus-manager -nfN 5-nor</userinput>
    Trying 5-noraa.pairs ... skipped.
    Trying 5-norab.pairs ... taken and processing ...
</screen>

<screen>
    <prompt>node_3$</prompt> <userinput>tricensus-manager -nfN 5-nor</userinput>
    Trying 5-noraa.pairs ... skipped.
    Trying 5-norab.pairs ... skipped.
    Trying 5-norac.pairs ... taken and processing ...
</screen>

   <para>
    Note that we pass a prefix of <filename>5-nor</filename> to avoid
    catching the master file <filename>5.pairs</filename>.  It is
    possibly safer simply to move <filename>5.pairs</filename> out of
    the way (or rename it so it does not have the
    <filename>.pairs</filename> extension and therefore will not be
    picked up).
   </para>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regconcat">regconcat</link>,
    <link linkend="man-sigcensus">sigcensus</link>,
    <link linkend="man-tricensus">tricensus</link>,
    <link linkend="man-tricensus-mpi">tricensus-mpi</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- Triangulation Census Manager (MPI) -->

 <refentry id="man-tricensus-mpi">
  <refmeta>
   <refentrytitle>tricensus-mpi</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>tricensus-mpi</refname>
   <refpurpose>Distribute a triangulation census amongst several machines using &mpi;</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>tricensus-mpi</command>
    <arg><option>-D, --depth=</option><replaceable>levels</replaceable></arg>
    <arg><option>-x, --dryrun</option></arg>
    <group>
     <arg><option>-o, --orientable</option></arg>
     <arg><option>-n, --nonorientable</option></arg>
    </group>
    <group>
     <arg><option>-f, --finite</option></arg>
     <arg><option>-d, --ideal</option></arg>
    </group>
    <group>
     <arg><option>-m, --minimal</option></arg>
     <arg><option>-M, --minprime</option></arg>
     <arg><option>-N, --minprimep2</option></arg>
    </group>
    <arg choice="req"><replaceable>pairs-file</replaceable></arg>
    <arg choice="req"><replaceable>output-file-prefix</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    Allows multiple processes, possibly running on different machines, to
    collaborate in forming a census of 3-manifold triangulations.
    Coordination is done through &mpi; (the Message Passing Interface),
    and the entire census is run as a single &mpi; job.
   </para>
   <note><para>
    This program is well suited for running on a formal cluster-like
    infrastructure.  For a more ad-hoc census manager that does not
    rely on such infrastructure, see the
    <link
     linkend="man-tricensus-manager"><command>tricensus-manager</command></link>
    utility instead.
   </para></note>
   <para>
    In preparing a census to be distributed amongst several processes or
    machines, the census must be split into smaller pieces.
    Running <link linkend="man-tricensus"><command>tricensus</command></link>
    with option <option>--genpairs</option> (which is very fast) will create
    a list of face pairings, each of which must be analysed in order to
    complete the census.
   </para>
   <para>
    The full list of face pairings should be stored in a single file,
    which is passed on the command-line as
    <replaceable>pairs-file</replaceable>.
    This file must contain one face pairing per line, and each of these
    face pairings must be in canonical form (i.e., must be a
    minimal representative of its isomorphism class).  Note that the face
    pairings generated by
    <link linkend="man-tricensus"><userinput>tricensus
    --genpairs</userinput></link> are guaranteed to satisfy these conditions.
   </para>
   <note><para>
    Whereas <command>tricensus-mpi</command> uses a single large face
    pairings file (with &mpi; handling the distribution of pairings to
    individual processes),
    the alternative <command>tricensus-manager</command>
    uses many small face pairings files (with individual processes
    claiming individual files to work on).
   </para></note>
   <para>
    This <command>tricensus-mpi</command> utility has two modes of
    operation: default mode, and subsearch mode.  These are explained
    separately under <link linkend="man-tricensus-mpi-modes">modes
    of operation</link> below.
   </para>
   <para>
    In both modes, one &mpi; process acts as the controller and the remaining
    processes each act as slaves.  The controller reads the list of face
    pairings from <replaceable>pairs-file</replaceable>, constructs a
    series of tasks based on these, and farms these tasks
    out to the slaves for processing.  Each slave processes one task
    at a time, asking the controller for a new task when it is finished
    with the previous one.
   </para>
   <para>
    At the end of each task, if any triangulations were found then
    the slave responsible will save these triangulations to an output file.
    The output file will have a name of the form
    <filename><replaceable>output-file-prefix</replaceable>_<replaceable>p</replaceable>.rga</filename>
    in default mode or
    <filename><replaceable>output-file-prefix</replaceable>_<replaceable>p</replaceable>-<replaceable>s</replaceable>.rga</filename>
    in subsearch mode, where <replaceable>p</replaceable> is the number
    of the face pairing being processed, and <replaceable>s</replaceable>
    is the number of the subsearch within that face pairing
    (both face pairings and subsearches are numbered from 1 upwards).
    If no triangulations were found then the slave will write no output file.
   </para>
   <para>
    The controller and slave
    processes all take the same <command>tricensus-mpi</command>
    options (excluding &mpi;-specific options, which are generally supplied
    by an &mpi; wrapper program such as <command>mpirun</command> or
    <command>mpiexec</command>).
    The different roles of the processes are determined solely by their
    &mpi; process rank (the controller is always the process with rank 0).
    It should therefore be possible to start all &mpi; processes by
    running a single command, as illustrated in the examples below.
   </para>
   <para>
    As the census progresses, the controller keeps a detailed log of each
    slave's activities, including how long each slave task has taken and how
    many triangulations have been found.  This log is written to the file
    <filename><replaceable>output-file-prefix</replaceable>.log</filename>.
    The utility
    <link linkend="man-tricensus-mpi-status"><command>tricensus-mpi-status</command></link>
    is able to parse this log and produce a shorter human-readable summary.
   </para>
   <tip><para>
    Once the census is complete, the
    <link linkend="man-regconcat"><command>regconcat</command></link>
    command may be used to combine the many small output files
    into one large topology data file for easier handling.
   </para></tip>
  </refsect1>

  <refsect1 id="man-tricensus-mpi-modes">
   <title>Modes of Operation</title>
   <para>
    As discussed above, there are two basic modes of operation.
    These are default mode (used when <option>--depth</option> is not
    passed), and subsearch mode (used when <option>--depth</option> is
    passed).
   </para>
   <itemizedlist>
    <listitem><para>
     In <emphasis>default mode</emphasis>, the controller simply
     reads the list of face pairings and gives each
     to a slave for processing, one after another.  In other words,
     each slave task is the entire subcensus for a single face pairing.
    </para></listitem>
    <listitem><para>
     In <emphasis>subsearch mode</emphasis>, more work is pushed to
     the controller and the slave tasks are shorter.  Here the
     controller reads one face pairing at a time and begins processing
     that face pairing.  A fixed depth is supplied in the argument
     <option>--depth</option>; each time that depth is reached in the
     search tree, the
     subsearch from that point on is given as a task to the next idle slave.
     Meanwhile the controller backtracks (as though the subsearch had
     finished) and continues, farming the next subsearch out when
     the given depth is reached again, and so on.
    </para></listitem>
   </itemizedlist>
   <para>
    The modes can be visualised as follows.
    For each face pairing, consider the corresponding recursive search
    as a large search tree.  In default mode, the entire tree is
    processed at once as a single slave task.  In subsearch mode, each
    subtree rooted at the given depth is processed as a separate slave
    task (and all processing between the root and the given depth is
    done by the controller).
   </para>
   <para>
    The main difference between the different modes of operation is
    the lengths of the slave tasks, which can have a variety of effects.
   </para>
   <itemizedlist>
    <listitem><para>
     In default mode the slave tasks are
     quite long.  If all slaves finish together this is quite efficient,
     but if the finish times are staggered then the census may become
     very inefficient towards the end (with some slaves sitting idle for
     a long time as they wait for the remaining slaves to finish).
    </para></listitem>
    <listitem><para>
     As we move to subsearch mode with increasing depth, the slave
     tasks become shorter and the slaves finish times will be closer
     together (thus avoiding the inefficiency of several slaves sitting
     idle as described above).  Moreover, with a more refined subsearch,
     the progress information stored in the log will be more detailed,
     giving a better idea of how long the census has to go.  On the
     other hand, more work is pushed to the single-process controller
     (risking a bottleneck if the depth is too great, with slaves
     sitting idle as they wait for new tasks).  In addition the &mpi; overhead
     is greater, and the number of output files can become extremely large.
    </para></listitem>
   </itemizedlist>
   <para>
    In the end, experimentation is the best way to decide whether to run
    in subsearch mode and at what depth.  Be aware of the option
    <option>--dryrun</option>, which can give a quick overview of the
    search space (and in particular, show how many subsearches are
    required for each face pairing at any given depth).
   </para>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <para>
    The census options accepted by <command>tricensus-mpi</command>
    have identical behaviour to those same options when passed to
    <command>tricensus</command>.  See the
    <link linkend="man-tricensus"><command>tricensus</command> reference</link>
    for further details.
   </para>
   <para>
    Note that some <command>tricensus</command> options are not
    available here (e.g., tetrahedra and boundary options), since these must
    be supplied earlier on when generating the initial list of face pairings
    through <userinput>tricensus --genpairs</userinput>.
   </para>
   <para>
    The remaining options specific to <command>tricensus-mpi</command>
    are as follows.
   </para>
   <variablelist>
    <varlistentry>
     <term><option>-D, --depth=</option><replaceable>levels</replaceable></term>
     <listitem>
      <para>
       Indicates that subsearch mode should be used (instead of default
       mode).  The argument <replaceable>levels</replaceable> specifies
       at what depth in the search tree processing should pass from the
       controller to a new slave task.
      </para>
      <para>
       The given depth must be strictly positive (running at depth zero
       is equivalent to running in default mode).
      </para>
      <para>
       See the <link linkend="man-tricensus-mpi-modes">modes of
       operation</link> section above for further information, as well
       for hints on choosing a good value for <replaceable>levels</replaceable>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-x, --dryrun</option></term>
     <listitem>
      <para>
       Specifies that a fast dry run should be performed, instead of a
       full census.
      </para>
      <para>
       In a dry run, each time a slave accepts a task it
       will immediately mark it as finished with no triangulations found.
       The behaviour of the controller remains unchanged.
      </para>
      <para>
       The result will be an empty census.  The value of a dry run is
       in the log file, which will show precisely how face pairings
       would be divided into subsearches in a real census run.
       In particular, the log file will show how
       many subsearches each face pairing produces (the utility
       <link linkend="man-tricensus-mpi-status"><command>tricensus-mpi-status</command></link>
       can help extract this information from the log).
      </para>
      <para>
       At small subsearch depths, a dry run should be extremely fast.
       As the given depth increases however, the dry run will become
       slower due to the extra work given to the controller.
      </para>
      <para>
       This option is only useful in subsearch mode (it can be used in
       default mode, but the results are uninteresting).
       See the <link linkend="man-tricensus-mpi-modes">modes of
       operation</link> section above for further details.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>Examples</title>
   <para>
    Suppose we wish to form a census of all 6-tetrahedron closed
    non-orientable triangulations, where the census is optimised for
    prime minimal P2-irreducible triangulations (and in particular, some
    triangulations that are not prime, minimal and P2-irreducible may be
    left out).
   </para>
   <para>
    We begin by using <command>tricensus</command> to generate a full
    list of face pairings.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus --genpairs -t 6 -i &gt; 6.pairs</userinput>
    Total face pairings: 97
    <prompt>example$</prompt>
</screen>

   <para>
    We now use <command>tricensus-mpi</command> to run the distributed
    census.  A wrapper program such as <command>mpirun</command>
    or <command>mpiexec</command> can generally
    be used to start the &mpi; processes, though this depends on your
    specific &mpi; implementation.  The command for running a distributed
    census on 10 processors for the &mpich; implementation of &mpi; is as
    follows.
   </para>

<screen>
    <prompt>example$</prompt> <userinput>mpirun -np 10 /usr/bin/tricensus-mpi -Nnf 6.pairs 6-nor</userinput>
    <prompt>example$</prompt>
</screen>

    <para>
     The current state of processing can be watched in the controller log
     <filename>6-nor.log</filename> with the help of
     <link linkend="man-tricensus-mpi-status"><command>tricensus-mpi-status</command></link>.
    </para>

<screen>
    <prompt>example$</prompt> <userinput>tricensus-mpi-status 6-nor.log</userinput>
    Pairing 1: done, 0 found
    ...
    Pairing 85: done, 0 found
    Pairing 86: done, 7 found
    Pairing 87: running
    Pairing 88: running
    Still running, 15 found, last activity: Wed Jun 10 05:57:34 2009
    <prompt>example$</prompt>
</screen>

    <para>
     Once the census is finished, the resulting triangulations will be
     saved in files such as
     <filename>6-nor_8.rga</filename>,
     <filename>6-nor_86.rga</filename> and so on.
    </para>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regconcat">regconcat</link>,
    <link linkend="man-sigcensus">sigcensus</link>,
    <link linkend="man-tricensus">tricensus</link>,
    <link linkend="man-tricensus-manager">tricensus-manager</link>,
    <link linkend="man-tricensus-mpi-status">tricensus-mpi-status</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- MPI Census Log Viewer -->

 <refentry id="man-tricensus-mpi-status">
  <refmeta>
   <refentrytitle>tricensus-mpi-status</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>tricensus-mpi-status</refname>
   <refpurpose>Summarise the log file of an &mpi; census of triangulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>tricensus-mpi-status</command>
    <arg choice="req"><replaceable>log-file</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    This utility reads a log file produced by a
    <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
    job, and writes a human-readable summary to standard output.
    It can be used for both jobs that have finished and jobs that are
    still running.
   </para>
   <para>
    The logs produced by <command>tricensus-mpi</command> are quite
    detailed, including timestamps, details of which slaves have taken
    which tasks, and how many triangulations each task has produced.
    This utility distills this information into an easy-to-read
    summary, with one line for each face pairing.
   </para>
   <para>
    Output will only be given for face pairings that have been
    examined so far (including face pairings whose processing is still
    underway), and will include:
   </para>
   <itemizedlist>
    <listitem><para>whether processing for each face pairing has
     finished;</para></listitem>
    <listitem><para>the number of triangulations found so far for each
     face pairing;</para></listitem>
    <listitem><para>the number of subsearches generated and/or finished
     for each face pairing (only relevant when running in subsearch
     mode).</para></listitem>
   </itemizedlist>
   <para>
    The final line of output will list the total number of triangulations
    found so far, whether the census has finished, and if not, when the
    last log entry was written.
   </para>
   <para>
    For further explanation of the terminology used above, see the
    <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
    reference.
   </para>
  </refsect1>

  <refsect1>
   <title>Examples</title>
   <para>
    See the
    <link linkend="man-tricensus-mpi"><command>tricensus-mpi</command></link>
    reference for a sample session in which
    <command>tricensus-mpi-status</command> is used.
   </para>
  </refsect1>

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-tricensus-mpi">tricensus-mpi</link>,
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>

 <!-- Isomorphism Tester -->

 <refentry id="man-trisetcmp">
  <refmeta>
   <refentrytitle>trisetcmp</refentrytitle>
   <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>trisetcmp</refname>
   <refpurpose>Compare triangulations between two &regina; data files</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
   <cmdsynopsis>
    <command>trisetcmp</command>
    <group>
     <arg><option>-m</option></arg>
     <arg><option>-n</option></arg>
    </group>
    <arg><option>-s</option></arg>
    <arg choice="req"><replaceable>file1</replaceable></arg>
    <arg choice="req"><replaceable>file2</replaceable></arg>
   </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>
   <para>
    This utility compares all triangulations in the first file against
    all triangulations in the second file.  Specifically, it looks to
    see which triangulations from <replaceable>file1</replaceable> are
    isomorphic to which triangulations from
    <replaceable>file2</replaceable>.
   </para>
   <para>
    The two given files must be &regina; data files.
    A full list of matches (or a full list of non-matches if
    <option>-n</option> is passed) is written to standard output.
   </para>
   <para>
    This utility can also do subcomplex testing instead of full
    isomorphism testing.  See the option <option>-s</option> for
    details.
   </para>
  </refsect1>

  <refsect1>
   <title>Options</title>
   <variablelist>
    <varlistentry>
     <term><option>-m</option> (default)</term>
     <listitem>
      <para>
       Output matches only.  All isomorphic matches between
       triangulations in <replaceable>file1</replaceable>
       and triangulations in <replaceable>file2</replaceable>
       will be listed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-n</option></term>
     <listitem>
      <para>
       Output non-matches only.  All triangulations from
       <replaceable>file1</replaceable> with no isomorphic match in
       <replaceable>file2</replaceable> will be listed, and vice versa.
      </para>
      <para>
       The behaviour of this option is slightly different when
       <option>-s</option> is passed; in particular, non-matches are
       only tested in one direction only (there is no vice versa as indicated
       above).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>-s</option></term>
     <listitem>
      <para>
       Instead of testing triangulations for isomorphism, test whether
       one triangulation is isomorphic to a subcomplex of the other.
      </para>
      <para>
       In the default case of <option>-m</option> (output matches only),
       this program outputs all instances where a triangulation from
       <replaceable>file1</replaceable> is isomorphic to a subcomplex
       of a triangulation from <replaceable>file2</replaceable>.
      </para>
      <para>
       In the case of <option>-n</option> (output non-matches only),
       this program outputs all triangulations from
       <replaceable>file1</replaceable> that are not isomorphic to a
       subcomplex of any triangulation from <replaceable>file2</replaceable>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  &submani18n;

  <refsect1>
   <title>See Also</title>
   <para>
    <link linkend="man-regina-kde">regina-kde</link>.
   </para>
  </refsect1>

  <refsect1>
   <title>Author</title>
   <para>
    &regina; was written by &regauthorplain; &regemail; with help from others;
    see the documentation for full details.
   </para>
  </refsect1>
 </refentry>
</reference>
