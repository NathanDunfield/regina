<chapter id="surfaces">
 <title>Normal Surfaces</title>

 <para>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="reginawhite.png" align="right"/>
   </imageobject>
  </inlinemediaobject>
  The primary motivation for originally writing &regina; was to create a
  tool for calculating vertex normal surfaces within a triangulation.
 </para>
 <para>
  A <firstterm>normal surface</firstterm> inside a 3-manifold
  triangulation is a surface composed entirely of normal discs.  A
  <firstterm>normal disc</firstterm> is a properly embedded disc within
  a single tetrahedron, and must be either a
  triangle (whose boundary runs across three of the four tetrahedron faces)
  or a quadrilateral (whose boundary runs across all four of the tetrahedron
  faces).
 </para>
 <para>
  The &regina; logo shown on this page illustrates all four possible
  triangle types and one of the three possible
  quadrilateral types within a tetrahedron.
 </para>
 <para>
  &regina; will also calculate <firstterm>almost normal
  surfaces</firstterm>, which have the same restrictions as normal
  surfaces except that they must contain precisely one additional
  octagonal disc.
  The boundary of an octagonal disc runs across each tetrahedron face twice,
  and there are three possible types of octagonal disc.
 </para>
 <note><para>
  More general definitions of almost normal surfaces allow for an annular
  piece instead of an octagonal disc.  &regina; works with the more
  restrictive octagon-only definition as described by Thompson
  <xref linkend="bib-thinposition"/> (which is much simpler
  to deal with computationally).
 </para></note>
 <para>
  Normal surfaces are represented as integer vectors indicating how many
  discs of each type in each tetrahedron are used to make up the surface.
 </para>
 <para>
  For a summary of enough normal surface theory to use this
  program, see a reference such as
  <xref linkend="bib-burton-convert"/> or <xref linkend="bib-hass-knotnp"/>.
 </para>

 <note>
  <para>
   A normal surface list in the packet tree must be a
   child packet of the triangulation in which the surfaces are contained.
  </para>
  <para>
   Furthermore, since each normal surface is stored as a vector relative
   to the triangulation's tetrahedra, a triangulation cannot be modified
   once it has a normal surface list as a child.  If you wish to edit
   such a triangulation, try cloning the packet (excluding descendants so
   the normal surfaces are not cloned as well) and edit the clone instead.
  </para>
  <para>
   Triangulations containing normal surface lists are marked with a small
   padlock in the packet tree to remind you that they cannot be edited.
  </para>
 </note>

 <sect1 id="surfaces-creation">
  <title>Creation</title>

  <para>
   A new list of normal surfaces can be created through the
   <menuchoice>
    <guimenu>Packet Tree</guimenu>
    <guimenuitem>New Normal Surface List</guimenuitem>
   </menuchoice>
   menu item (or the corresponding toolbar button).
  </para>
  <para>
   Only <firstterm>vertex normal surfaces</firstterm> will be placed in
   the new list; all other normal surfaces can be formed as convex
   combinations of these vertex surfaces.
  </para>
  <warning>
   <para>
    For <emphasis>almost</emphasis> normal surfaces, older versions of
    &regina; used to ignore any vertex surfaces with
    more than one octagonal disc.
    As of &regina;&nbsp;4.6, this behaviour has changed &mdash; now
    &regina; will keep surfaces with more than one octagon, though it
    still insists on at most one octagon <emphasis>type</emphasis>.
    This is important if you wish to use vertex almost normal
    surfaces as a basis for generating <emphasis>all</emphasis>
    almost normal surfaces, as suggested above.
   </para>
   <para>
    If you have a data file from &regina;&nbsp;4.5.1 or earlier,
    then any vertex surfaces with more than one octagon will have already been
    removed.  The only way to get them back is to re-run the almost normal
    surface enumeration using &regina;&nbsp;4.6 or later.
   </para>
  </warning>
  <para>
   Before the normal surface list is created, you will be asked for some
   additional details as follows.
   <glosslist>
    <glossentry>
     <glossterm>Create beneath</glossterm>
     <glossdef>
      <para>
       Here you must select the triangulation that will contain the new
       normal surfaces (this must be a triangulation already in
       the packet tree).
      </para>
     </glossdef>
    </glossentry>
    <glossentry id="surfaces-selectcoords">
     <glossterm>Coordinate system</glossterm>
     <glossdef>
      <para>
       Here you must select the coordinate system in which the vertex
       normal surfaces will be enumerated.
      </para>
      <para>
       Whether or not <emphasis>almost</emphasis>
       normal surfaces are enumerated (in addition to
       just normal surfaces) will depend upon this choice of coordinate system.
       Currently almost normal surfaces are only enumerated when using
       standard almost normal coordinates or quadrilateral-octagon coordinates.
      </para>
      <para>
       Note that this coordinate system refers only to the initial
       enumeration; you will
       be able to view these normal surfaces in a variety of different
       coordinate systems later on.
      </para>
      <para>
       Note also that this choice of coordinate system will affect which
       surfaces are produced.  For instance, quad normal
       coordinates produce spun normal surfaces which standard normal
       coordinates do not, and standard normal coordinates produce vertex
       links which quad normal coordinates do not.
      </para>
      <para>
       The available coordinate systems are described in detail
       in the documentation for the
       <link linkend="surfaces-defcoords">coordinates tab</link>.
       If there is a particular coordinate system that you regularly
       use, the default offering can be changed in the
       <link linkend="options-surfaces">normal surface preferences</link>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry id="surfaces-embeddedonly">
     <glossterm>Embedded surfaces only</glossterm>
     <glossdef>
      <para>
       Here you must specify whether the search should be restricted to
       embedded surfaces only (this is the default and is all that is
       considered in most of the published theory).
      </para>
      <para>
       Be aware that a search that is broadened to <emphasis>all</emphasis>
       surfaces (embedded, immersed and singular) could well take much
       longer to run than the corresponding embedded-only
       search.  Enumeration of immersed and singular surfaces is only
       supported for normal surfaces, not almost normal surfaces.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </para>
 </sect1>

 <sect1 id="surfaces-analysis">
  <title>Analysis</title>

  <para>
   Several properties of a normal surface list and its individual surfaces
   are available; most of these properties can be viewed by clicking on the
   different tabs in the normal surface list viewer.
  </para>

  <sect2 id="surfaces-viewlistprops">
   <title>Properties of the List</title>

   <para>
    Above all of the tabs in the surface list viewer, a header is displayed
    with some basic properties of the normal surface list.  These include:
    <itemizedlist>
     <listitem><para>
      a count of the total number of vertex normal surfaces contained in
      the list;
     </para></listitem>
     <listitem><para>
      a reminder of how the surface list was
      originally created, including the coordinate system used and
      whether or not the search was restricted
      to embedded surfaces only.  Note that this does
      not actually look at the surfaces in the list
      &ndash; an unrestricted search might have only produced embedded
      surfaces, but this reminder will still say
      <literal>embedded/immersed/singular</literal>.
     </para></listitem>
    </itemizedlist>
   </para>
   <tip><para>
    If the header says that the list was created using
    <emphasis>legacy</emphasis> almost normal coordinates, this means
    the list was created using &regina;&nbsp;4.5.1 or earlier, and that
    all surfaces with more than one octagon were deleted.
    See the notes below on
    <link linkend="surfaces-viewsurfacecoords">coordinates systems</link>
    for details.
   </para></tip>
  </sect2>

  <sect2 id="surfaces-summary">
   <title>Summary</title>

   <para>
    The first tab contains a summary of what kinds of surfaces were found.
    This summary breaks the total count down into several
    sub-counts, as illustrated in the screenshot below.
    These counts are first organised by boundary, where we distinguish
    between closed surfaces, bounded surfaces (which have real boundary)
    and non-compact surfaces (which have infinitely many normal or
    almost normal discs).  Within each section, the counts are then
    broken down further by Euler characteristic, orientability,
    and one-or-two-sidedness.
    For further information on these properties, see the documentation on
    <link linkend="surfaces-viewsurfaceprops">individual
    surface properties</link>.
   </para>
   <para>
    <screenshot>
     <screeninfo>The summary tab for a normal surface list</screeninfo>
     <mediaobject>
      <imageobject>
       <imagedata fileref="surfaces-summary.png"/>
      </imageobject>
      <textobject>
       <phrase>The summary tab for a normal surface list</phrase>
      </textobject>
      <caption><para>The summary tab for a normal surface list</para></caption>
     </mediaobject>
    </screenshot>
   </para>
  </sect2>

  <sect2 id="surfaces-viewsurfacecoords">
   <title>Individual Surface Coordinates</title>

   <para>
    The <guilabel>Surface Coordinates</guilabel> tab in the surface list
    viewer contains a table of all the vertex surfaces that form
    this list.  Each surface is presented as a vector in some underlying
    coordinate system (this coordinate system is displayed immediately
    above the table).
   </para>
   <para>
    Each row of this table represents a single normal surface.
    The left few columns of the table contain various surface
    properties (see the <link
    linkend="surfaces-viewsurfaceprops">individual surface properties</link>
    section below).  The remaining columns contain the actual surface
    coordinates.  This is illustrated in the screenshot below.
   </para>
   <para>
    <screenshot>
     <screeninfo>The coordinates tab for a normal surface list</screeninfo>
     <mediaobject>
      <imageobject>
       <imagedata fileref="surfaces-coords.png"/>
      </imageobject>
      <textobject>
       <phrase>The coordinates tab for a normal surface list</phrase>
      </textobject>
      <caption><para>The coordinates tab for a normal surface
       list</para></caption>
     </mediaobject>
    </screenshot>
   </para>
   <para>
    To change the coordinate system in which you are viewing the
    surfaces, simply select a new coordinate system from the drop-down
    box above the table.  Note that this will <emphasis>not</emphasis>
    regenerate the vertex normal surfaces in the new coordinate system;
    it will simply redisplay the surfaces that you already have in the new
    system.  So, for instance, if a spun surface is created during a quad
    space search and the surfaces are viewed in standard (tri-quad)
    coordinates, this spun surface will be redisplayed in the table with
    triangular coordinates of infinity.  Furthermore, vertex links (which
    are not found during a quad space search) will not suddenly
    appear in the list.
   </para>
   <para>
    The meanings of the individual coordinate columns in the table
    depend upon the underlying coordinate system as follows.
    <glosslist id="surfaces-defcoords">
     <glossentry id="surfaces-defstandard">
      <glossterm>Standard normal (tri-quad) coordinates</glossterm>
      <glossdef>
       <para>
        Standard normal coordinates simply count the number of triangular
        and quadrilateral discs of each type in each tetrahedron.
       </para>
       <para>
        Triangular coordinates are labelled
        <literal>0:0</literal>, <literal>0:1</literal>,
        <literal>0:2</literal>, <literal>0:3</literal>,
        <literal>1:0</literal>, <literal>1:1</literal>,
        <literal>1:2</literal>, <literal>1:3</literal>,
        <literal>2:0</literal>, etc.  Coordinate
        <literal><replaceable>t</replaceable>:<replaceable>v</replaceable></literal>
        represents the number of triangular discs in tetrahedron
        <replaceable>t</replaceable> that separate vertex
        <replaceable>v</replaceable> of that tetrahedron from the other
        three tetrahedron vertices
        (<replaceable>v</replaceable> will always be 0, 1, 2 or 3).
       </para>
       <para>
        Quadrilateral coordinates are labelled
        <literal>0:01/23</literal>, <literal>0:02/13</literal>,
        <literal>0:03/12</literal>, <literal>1:01/23</literal>,
        <literal>1:02/13</literal>, <literal>1:03/12</literal>,
        <literal>2:01/23</literal>, etc.  Coordinate
        <literal><replaceable>t</replaceable>:<replaceable>ab</replaceable>/<replaceable>cd</replaceable></literal>
        represents the number of quadrilateral discs in tetrahedron
        <replaceable>t</replaceable> that separate vertices
        <replaceable>a</replaceable> and <replaceable>b</replaceable>
        of that tetrahedron from vertices
        <replaceable>c</replaceable> and <replaceable>d</replaceable>
        of that tetrahedron
        (<replaceable>a</replaceable>, <replaceable>b</replaceable>,
        <replaceable>c</replaceable> and <replaceable>d</replaceable>
        will always be 0, 1, 2 and 3 in some order).
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-defquad">
      <glossterm>Quad normal coordinates</glossterm>
      <glossdef>
       <para>
        Quad normal coordinates are identical to standard normal
        (tri-quad) coordinates except that only quadrilateral discs are
        considered.
        See Tollefson <xref linkend="bib-quadspace"/> for details.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-defstandardan">
      <glossterm>Standard almost normal (tri-quad-oct) coordinates</glossterm>
      <glossdef>
       <para>
        Standard almost normal coordinates are identical to standard
        normal coordinates except that octagonal discs are also
        considered.
       </para>
       <para>
        Octagonal discs are labelled similarly to quadrilateral discs
        (each octagonal disc also separates some two vertices of the
        corresponding tetrahedron from the other two).  To make it clear
        which coordinates are which, each triangle label begins with a
        <literal>T</literal>, each quadrilateral label begins with
        a <literal>Q</literal> and each octagon label begins
        with a <literal>K</literal>.
       </para>
       <para>
        Although an almost normal surface is defined to have precisely
        one octagonal disc, surfaces here in standard almost normal coordinates
        are allowed to have no octagons at all, or several octagons
        (though at most one octagon <emphasis>type</emphasis> can be used).
        This becomes important if you wish to use vertex almost normal
        surfaces as a basis for generating <emphasis>all</emphasis>
        almost normal surfaces.
       </para>
       <para>
        In contrast, see <link linkend="surfaces-deflegacyan">legacy
        almost normal coordinates</link> below, where surfaces with more
        than one octagon are explicitly removed.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-defquadoct">
      <glossterm>Quad-oct almost normal coordinates</glossterm>
      <glossdef>
       <para>
        Quad-oct almost normal coordinates are identical to standard
        almost normal (tri-quad-oct) coordinates, except that only
        quadrilateral and octagonal discs are considered.
        See <xref linkend="bib-burton-quadoct"/> for details.
       </para>
       <para>
        Like standard almost normal coordinates, surfaces with no
        octagons or many octagons (but all of the same type) are allowed.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-deflegacyan">
      <glossterm>Legacy almost normal (pruned tri-quad-oct)
       coordinates</glossterm>
      <glossdef>
       <para>
        These are identical to standard almost normal (tri-quad-oct)
        coordinates, except that surfaces with more than one octagon
        are removed entirely from the list.
       </para>
       <para>
        This was in fact the behaviour in &regina; versions 4.5.1 and
        earlier.  This behaviour was changed in &regina;&nbsp;4.6 because
        it is important to keep surfaces with multiple octagons if you wish
        to generate new surfaces as convex combinations of old surfaces.
       </para>
       <para>
        Unfortunately, if a surface list was created in &regina;&nbsp;4.5.1
        or earlier then such surfaces will already have been removed, and
        there is no way to get them back (except to run a new enumeration of
        almost normal surfaces).  Such lists will always be displayed
        with the label <emphasis>legacy almost normal coordinates</emphasis>
        so it is clear what has happened.
       </para>
       <para>
        You cannot create a <emphasis>new</emphasis> normal
        surface list in legacy coordinates.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-defedgewt">
      <glossterm>Edge weight coordinates</glossterm>
      <glossdef>
       <para>
        The coordinates are labelled <literal>0</literal>,
        <literal>1</literal>, <literal>2</literal>, etc.  Coordinate
        <replaceable>e</replaceable> represents the number of times the
        surface crosses edge <replaceable>e</replaceable> of the
        triangulation.
       </para>
       <para>
        Edge numbers and the tetrahedron edges/vertices to which they
        correspond can be seen in the skeleton section of the
        <link linkend="tri-vertexedgeface">triangulation viewer</link>.
       </para>
       <para>
        Edge weight coordinates are simply offered as a different way of
        viewing an existing list of normal surfaces.  You cannot
        <emphasis>enumerate</emphasis> a new list of surfaces
        in edge weight coordinates.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-deffacearc">
      <glossterm>Face arc coordinates</glossterm>
      <glossdef>
       <para>
        The coordinates are labelled
        <literal>0:0</literal>, <literal>0:1</literal>, <literal>0:2</literal>,
        <literal>1:0</literal>, <literal>1:1</literal>, <literal>1:2</literal>,
        <literal>2:0</literal>, etc.  Coordinate
        <literal><replaceable>f</replaceable>:<replaceable>v</replaceable></literal>
        represents the number of times the surface slices through face
        <replaceable>f</replaceable> of the triangulation in an arc
        that truncates vertex <replaceable>v</replaceable> of that face
        (<replaceable>v</replaceable> will always be 0, 1 or 2).
       </para>
       <para>
        Face numbers and the tetrahedron faces/vertices to which they
        correspond can be seen in the skeleton section of the
        <link linkend="tri-vertexedgeface">triangulation viewer</link>.
       </para>
       <para>
        Like edge weight coordinates, face arc coordinates are offered as a
        different way of viewing an existing normal surface list.  You cannot
        <emphasis>enumerate</emphasis> a new list of surfaces
        in face arc coordinates.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </para>
  </sect2>

  <sect2 id="surfaces-viewsurfaceprops">
   <title>Individual Surface Properties</title>

   <para>
    As described in the
    <link linkend="surfaces-viewsurfacecoords">surface coordinates</link>
    section above, the <guilabel>Surface Coordinates</guilabel> tab
    presents a table of all of the normal surfaces in the list.
   </para>
   <para>
    In the very leftmost column of this table, the individual surfaces
    are numbered from 0 to <replaceable>S</replaceable>-1, where
    <replaceable>S</replaceable> is the total number of surfaces in the list.
   </para>
   <para>
    The next few columns describe several different properties of the
    surfaces, as described below.  Note that not all of these properties
    appear in all situations (for instance, &regina; does not yet calculate
    Euler characteristic for non-compact surfaces, and the orientability
    column will not be shown for lists that might include
    immersed or singular surfaces).
   </para>
   <para>
    <glosslist>
     <glossentry id="surfaces-propname">
      <glossterm>Name</glossterm>
      <glossdef>
       <para>
        Individual surfaces can be optionally named by the user
        to help keep track of which surface is which.
        Surface names are not used by &regina;, and do not need to be unique.
       </para>
       <para>
        To rename a surface, just click on the corresponding table cell
        and type the new name directly into that table cell.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-propeuler">
      <glossterm>Euler</glossterm>
      <glossdef><para>
       This column shows the Euler characteristic of each surface.
      </para></glossdef>
     </glossentry>
     <glossentry id="surfaces-proporient">
      <glossterm>Orient</glossterm>
      <glossdef><para>
       This column shows whether or not each surface is orientable.
      </para></glossdef>
     </glossentry>
     <glossentry id="surfaces-propsides">
      <glossterm>Sides</glossterm>
      <glossdef><para>
       This column shows whether each surface is one-sided or two-sided.
      </para></glossdef>
     </glossentry>
     <glossentry id="surfaces-boundary">
      <glossterm>Bdry</glossterm>
      <glossdef><para>
       This column describes whether each surface is bounded.
       It will take one of the following values:
       <glosslist>
        <glossentry>
         <glossterm>Closed</glossterm>
         <glossdef><para>
          Indicates that the surface is compact (contains finitely many discs)
          and closed (does not have any boundary).
         </para></glossdef>
        </glossentry>
        <glossentry>
         <glossterm>Real Bdry</glossterm>
         <glossdef><para>
          Indicates that the surface is compact (contains finitely many discs)
          and bounded (meets the boundary of the enclosing triangulation).
         </para></glossdef>
        </glossentry>
        <glossentry>
         <glossterm>Infinite</glossterm>
         <glossdef><para>
          Indicates that the surface is non-compact, i.e., contains infinitely
          many normal or almost normal discs.  Examples of such surfaces are
          <firstterm>spun normal surfaces</firstterm>
          <xref linkend="bib-tillus-spun"/>,
          which can be found in quad space for some ideal triangulations.
         </para></glossdef>
        </glossentry>
       </glosslist>
      </para></glossdef>
     </glossentry>
     <glossentry id="surfaces-proplink">
      <glossterm>Link</glossterm>
      <glossdef><para>
       If a normal surface or a rational multiple of that surface
       is recognised as being a link of any interesting subcomplexes
       within the triangulation, these subcomplexes will be listed here.
       The following links are currently recognised:
       <glosslist>
        <glossentry>
         <glossterm>Vertex</glossterm>
         <glossdef><para>
          Indicates that the surface is a vertex link.
          The corresponding vertex number in the triangulation will be
          listed.
         </para>
         <para>
          Vertex numbers and the tetrahedron vertices to which they
          correspond can be seen in the skeleton section of the
          <link linkend="tri-vertexedgeface">triangulation viewer</link>.
         </para></glossdef>
        </glossentry>
        <glossentry>
         <glossterm>Thin Edge</glossterm>
         <glossdef><para>
          Indicates that the surface is a thin edge link.
          The corresponding edge number(s) in the triangulation will be
          listed.  Note that a surface might be both the link of one thin
          edge and also (independently) the link of another thin edge.
         </para>
         <para>
          Edge numbers and the tetrahedron edges/vertices to which they
          correspond can be seen in the skeleton section of the
          <link linkend="tri-vertexedgeface">triangulation viewer</link>.
         </para></glossdef>
        </glossentry>
       </glosslist>
      </para></glossdef>
     </glossentry>
     <glossentry>
      <glossterm>Type</glossterm>
      <glossdef><para>
       If a normal surface is recognised as playing a particular role
       within the triangulation, that role will be listed in this column.
       At most one such role will be displayed for any particular surface.
       The following roles are currently recognised:
       <glosslist>
        <glossentry id="surfaces-propsplitting">
         <glossterm>Splitting</glossterm>
         <glossdef><para>
          Indicates that the surface is a splitting surface (contains
          precisely one quadrilateral per tetrahedron and no other normal
          or almost normal discs).
         </para></glossdef>
        </glossentry>
        <glossentry id="surfaces-propcentral">
         <glossterm>Central</glossterm>
         <glossdef><para>
          Indicates that although it is not a splitting surface,
          the surface is still a central surface (contains at most one
          normal or almost normal disc per tetrahedron).  A number will
          be displayed indicating the number of tetrahedra
          that this surface meets (i.e., the number of normal or almost
          normal discs in the surface).
         </para></glossdef>
        </glossentry>
       </glosslist>
      </para></glossdef>
     </glossentry>
     <glossentry id="surfaces-propoctagon">
      <glossterm>Octagon</glossterm>
      <glossdef>
       <para>
        This column only appears when dealing with almost normal surfaces.
        Its purpose is to indicate how many octagonal discs each surface
        contains, and where they are.
       </para>
       <para>
        For a given surface, if the cell in this column is empty then
        the surface does not contain any octagonal discs at all (i.e., it is a
        regular <emphasis>normal</emphasis> surface).
        Otherwise, it will contain a single coordinate label
        and the corresponding number of octagons,
        such as <literal>K2:&nbsp;03/12 (3&nbsp;octs)</literal>.
       </para>
       <para>
        Note that there can only ever be one coordinate
        <emphasis>position</emphasis> in any given surface
        containing octagonal discs (this is a constraint forced upon the
        enumeration procedure).  However, as of &regina;&nbsp;4.6,
        this coordinate position may contain more than one octagon.
        See the discussion on <link linkend="surfaces-deflegacyan">legacy
        almost normal coordinates</link> for further details.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </para>
  </sect2>

  <sect2 id="surfaces-viewmatching">
   <title>Original Matching Equations</title>

   <para>
    The <guilabel>Matching Equations</guilabel> tab in the surface list
    viewer contains a table of the individual matching equations that
    were used to form this list.
   </para>
   <para>
    The matching equations are presented in the coordinate system that
    was used to originally create this surface list (see the
    <link linkend="surfaces-creation">surface list creation reference</link>).
    This coordinate system is displayed above all of the tabs in the
    surface list viewer.
   </para>
   <para>
    Each row of this table represents an individual matching equation.
    A matching equation involves setting a linear combination of surface
    coordinates to zero; the coefficients of this linear combination are
    shown in the individual table cells.  A description of what the individual
    surface coordinates mean can be found in the
    <link linkend="surfaces-viewsurfacecoords">individual surface
    coordinates</link> section above.
   </para>
  </sect2>

  <sect2 id="surfaces-compat">
   <title>Compatibility</title>

   <para>
    The <guilabel>Compatibility</guilabel> tab in the surface list
    viewer shows which pairs of surfaces are compatible with each other,
    both locally and globally.  These concepts are defined as follows:
   </para>
   <para>
    <glosslist>
     <glossentry id="surfaces-localcompat">
      <glossterm>Locally compatible</glossterm>
      <glossdef>
       <para>
        Two surfaces are <emphasis>locally compatible</emphasis> if
        they are able to avoid intersection in any given tetrahedron of
        the triangulation (though not necessarily in all tetrahedra
        simultaneously).
       </para>
       <para>
        In other words, two surfaces are locally compatible if, in each
        tetrahedron, they <emphasis>together</emphasis> use at most
        one quadrilateral or octagonal disc type.
       </para>
      </glossdef>
     </glossentry>
     <glossentry id="surfaces-globalcompat">
      <glossterm>Globally compatible</glossterm>
      <glossdef>
       <para>
        Two surfaces are <emphasis>globally compatible</emphasis> if
        they are able to avoid intersection in <emphasis>all</emphasis>
        tetrahedra of the triangulation simultaneously.
       </para>
       <para>
        In other words, two surfaces are globally compatible if they can
        be made <emphasis>disjoint</emphasis> within the triangulation.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </para>
   <para>
    The <guilabel>Compatibility</guilabel> tab contains two matrices, one for
    local compatibility and one for global compatibility.  You can
    switch between these two matrices by using the drop-down box labelled
    <guilabel>Display matrix</guilabel>.
   </para>
   <para>
    Each matrix has dimensions
    <replaceable>S</replaceable>-by-<replaceable>S</replaceable>,
    where <replaceable>S</replaceable> is the total number of surfaces
    in the list.  Rows and columns are both numbered from 0 to
    <replaceable>S</replaceable>-1 inclusive, and the
    (<replaceable>x</replaceable>,<replaceable>y</replaceable>) cell of
    the matrix is filled if and only if surfaces
    <replaceable>x</replaceable> and <replaceable>y</replaceable> are
    compatible.  Here we use same numbering scheme as in the first column of
    the <link linkend="surfaces-viewsurfaceprops">coordinate viewer</link>.
   </para>
   <para>
    <screenshot>
     <screeninfo>The global compatibility matrix for a normal
      surface list</screeninfo>
     <mediaobject>
      <imageobject>
       <imagedata fileref="surfaces-compat.png"/>
      </imageobject>
      <textobject>
       <phrase>The global compatibility matrix for a
        normal surface list</phrase>
      </textobject>
      <caption><para>The global compatibility matrix for a
       normal surface list</para></caption>
     </mediaobject>
    </screenshot>
   </para>
   <para>
    Note that the global compatibility test comes with some constraints.
    Specifically, it cannot be run with surfaces that are empty, disconnected
    or non-compact (such as spun normal surfaces).  For any such surfaces,
    the corresponding rows and columns will be hashed out in the matrix
    as illustrated below.
   </para>
   <para>
    <screenshot>
     <screeninfo>Hashing out rows and columns for
      spun normal surfaces</screeninfo>
     <mediaobject>
      <imageobject>
       <imagedata fileref="surfaces-compat-hash.png"/>
      </imageobject>
      <textobject>
       <phrase>Hashing out rows and columns for
        spun normal surfaces</phrase>
      </textobject>
      <caption><para>Hashing out rows and columns for
       spun normal surfaces</para></caption>
     </mediaobject>
    </screenshot>
   </para>
   <para>
    For very large lists of surfaces, the compatibility matrices will
    not be generated automatically (since this could take a long time
    and/or require a significant amount of memory).  In this case, you
    can still compute the matrices by pressing the
    <guilabel>Calculate</guilabel> button at the top of the tab.
    The default threshold for automatic calculation is 100 surfaces,
    though you can change this in the
    <link linkend="options-surfaces">normal surface preferences</link>.
   </para>
  </sect2>
 </sect1>

 <sect1 id="surfaces-crushandcut">
  <title>Crushing and Cutting</title>

  <para>
   In certain situations normal surfaces can be used to
   decompose the underlying triangulation into smaller and/or simpler
   components.  The available ways in which this can be done are as
   follows.
  </para>

  <sect2 id="surfaces-crush">
   <title>Crushing a Surface</title>
   <para>
    A normal surface can be crushed to a point in the underlying
    triangulation by selecting the surface within the table
    and invoking the
    <menuchoice>
     <guimenu>Normal Surfaces</guimenu>
     <guimenuitem>Crush Surface</guimenuitem>
    </menuchoice>
    menu item.
   </para>
   <para>
    The original triangulation will not be changed; a new triangulation
    in which the selected surface has been crushed
    will appear as a child packet of this surface list.
   </para>
   <para>
    Note that crushing a normal surface might change the topology of the
    underlying 3-manifold (beyond the simple act of slicing along the
    surface) and in some cases might introduce ideal vertices
    or even invalid edges.  For details see
    <function><classname>NNormalSurface</classname>::crush()</function>
    in the &regenginedocs;.
   </para>
   <para>
    Why crush a surface if it can have such nasty side-effects?
    The advantage is that, unlike the cutting operation described
    below, crushing a surface can only ever <emphasis>reduce</emphasis>
    the number of tetrahedra in a triangulation (the worst case is
    where the surface only contains vertex links, whereupon the number
    of tetrahedra will remain the same).
   </para>
   <para>
    In general you should only crush a normal surface when there are
    theoretical reasons to know that this is safe.  Examples of safe
    scenarios can be found in Jaco and Rubinstein's paper on
    0-efficiency <xref linkend="bib-0-efficiency"/>.
   </para>
  </sect2>
  <sect2 id="surfaces-cut">
   <title>Cutting Along a Surface</title>
   <para>
    Instead of crushing a surface to a point, one might wish to simply
    slice along the surface and subdivide the resulting polyhedra into
    tetrahedra to produce a new triangulation.
   </para>
   <para>
    This has the advantage over crushing in that it will never change
    the topology of the underlying 3-manifold beyond the act of simply
    slicing along the surface.  It will also never introduce new ideal
    vertices or invalid edges.
   </para>
   <para>
    The disadvantage is that, after cutting along a surface,
    the number of tetrahedra in the triangulation can potentially
    skyrocket.  This has severe implications if you wish to do anything
    computationally intensive with the resulting triangulation(s).
   </para>
   <para>
    To cut along a normal surface, select the surface within the table
    and invoke the
    <menuchoice>
     <guimenu>Normal Surfaces</guimenu>
     <guimenuitem>Cut Along Surface</guimenuitem>
    </menuchoice>
    menu item.
    As with crushing, the original triangulation will not be changed;
    the resulting cut-open triangulation will be added to the packet
    tree as a new child of this surface list.
   </para>
   <tip><para>
    When crushing or cutting along a two-sided surface, it is possible
    that you will end up with a disconnected triangulation.
    The menu item
    <menuchoice>
     <guimenu>Triangulation</guimenu>
     <guimenuitem>Extract Components</guimenuitem>
    </menuchoice>
    can be used to split this triangulation into its connected components.
    See the section on
    <link linkend="tri-decomposition-component">component decomposition</link>
    for details.
   </para></tip>
  </sect2>
 </sect1>

 <sect1 id="surfaces-filtering">
  <title>Filtering</title>

  <para>
   Sometimes you are faced with a very long list of surfaces from which
   you wish to extract just the tori, or just the discs, or some other
   subset of surfaces described by one or more simple constraints.
   For tasks such as these, surface filters can be used.
  </para>
  <para>
   A surface filter essentially represents some series of tests that can
   be performed upon a surface.  Tests can include a variety of easily
   calculable properties such as orientability and Euler characteristic.
   At its most basic level, a surface filter is a device that either
   accepts or rejects each surface that is passed through it.
  </para>
  <para>
   Each surface filter is stored as a separate packet in the packet tree.
   Details of the types of filter that can be created are discussed
   in the <link linkend="surfaces-filtering-creating">following
   section</link>.
  </para>
  <para>
   To restrict a normal surface list according to some filter, open the
   surface list <link linkend="surfaces-viewsurfacecoords">coordinate
   viewer</link> where the entire list of surfaces is displayed.
   Above the table of coordinates is a drop-down box filled with the
   available filters.  If a filter is selected from this
   box then the surface list is restricted to include only those
   surfaces that the selected filter accepts.  To remove the filter, select
   the <guilabel>None</guilabel> option from this same drop-down box.
  </para>

  <sect2 id="surfaces-filtering-creating">
   <title>Creating Filters</title>

   <para>
    Filters are created through the
    <menuchoice>
     <guimenu>Packet Tree</guimenu>
     <guimenuitem>New Filter</guimenuitem>
    </menuchoice>
    menu item (or the corresponding toolbar button).  The following types
    of filter are available.
   </para>

   <sect3 id="surfaces-filterprop">
    <title>Filter by Properties</title>

    <para>
     A property-based filter allows surfaces to be restricted according
     to a variety of easily calculable properties.
    </para>
    <para>
     To be accepted a surface must satisfy all of the restrictions listed
     in the filter.  For instance, if a filter restricts by
     orientability (allow orientable surfaces only), by compactness
     (allow compact surfaces only) and also
     by Euler characteristic (allow Euler characteristic 1 only), then
     the filter will accept normal discs and nothing else.
    </para>
    <para>
     The properties by which surfaces can be restricted are as follows.
     <variablelist>
      <varlistentry>
       <term>Orientability</term>
       <listitem><para>
        This restriction can be used to only allow orientable surfaces
        or only allow non-orientable surfaces.
       </para></listitem>
      </varlistentry>
      <varlistentry>
       <term>Compactness</term>
       <listitem><para>
        This restriction can be used to only allow compact surfaces
        (i.e., surfaces with finitely many discs) or only allow
        non-compact surfaces (e.g., spun normal surfaces).
       </para></listitem>
      </varlistentry>
      <varlistentry>
       <term>Boundary</term>
       <listitem><para>
        This restriction can be used to only allow surfaces with real
        boundary edges or only allow surfaces with no real boundary edges.
        Note that spun normal surfaces, though they are not closed, do
        not have real boundary edges.
       </para></listitem>
      </varlistentry>
      <varlistentry>
       <term>Euler Characteristic</term>
       <listitem><para>
        This restriction can be used to only allow surfaces whose Euler
        characteristic belongs to a given list.
       </para></listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect3>

   <sect3 id="surfaces-filtercomb">
    <title>Combination Filter</title>

    <para>
     A combination filter is a high-level filter that combines some
     other group of filters using boolean <literal>AND</literal> or
     <literal>OR</literal>.  The combination filter will combine all
     packet filters found directly beneath it in the packet tree.
    </para>
    <para>
     For instance, to create a filter that accepts either discs or tori,
     you can create a <link linkend="surfaces-filterprop">property
     filter</link> for discs and another property filter for tori.
     These are both placed within the packet tree directly beneath
     a boolean <literal>OR</literal> combination filter, as
     illustrated in the following screenshot.
    </para>
    <screenshot>
     <screeninfo>A sample combination filter</screeninfo>
     <mediaobject>
      <imageobject>
       <imagedata fileref="filtercombeg.png"/>
      </imageobject>
      <textobject>
       <phrase>A sample combination filter</phrase>
      </textobject>
      <caption><para>A sample combination filter</para></caption>
     </mediaobject>
    </screenshot>
    <para>
     <inlinemediaobject>
      <imageobject>
       <imagedata fileref="filtercombtree.png" align="right"/>
      </imageobject>
     </inlinemediaobject>
     Note that a combination filter will only combine its immediate children.
     Suppose for instance that a combination filter
     <replaceable>C</replaceable> has child filters
     <replaceable>P</replaceable> and <replaceable>Q</replaceable>,
     and that <replaceable>Q</replaceable> in turn has child filters
     <replaceable>X</replaceable> and <replaceable>Y</replaceable>,
     as illustrated in the diagram to the right.
     Then <replaceable>C</replaceable> forms a boolean combination of
     <replaceable>P</replaceable> and <replaceable>Q</replaceable> only.
    </para>
   </sect3>
  </sect2>
 </sect1>
</chapter>
